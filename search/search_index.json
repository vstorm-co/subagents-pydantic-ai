{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Subagents for Pydantic AI","text":"Subagents for Pydantic AI <p> Multi-Agent Orchestration for Pydantic AI </p> <p> </p> <p>Subagents for Pydantic AI adds multi-agent delegation to any Pydantic AI agent. Spawn specialized subagents that run synchronously (blocking), asynchronously (background), or let the system auto-select the best mode.</p> <p>Think of it as the building blocks for multi-agent systems - where a parent agent can delegate specialized tasks to child agents, and those children can have their own children.</p>"},{"location":"#why-use-subagents","title":"Why use Subagents?","text":"<ol> <li> <p>Specialization: Each subagent has focused instructions and tools for its domain. A \"researcher\" agent researches, a \"writer\" agent writes.</p> </li> <li> <p>Parallel Execution: Run multiple tasks simultaneously in async mode. Start a research task, continue with other work, check results later.</p> </li> <li> <p>Nested Hierarchies: Subagents can spawn their own subagents. Build complex multi-agent workflows with natural delegation patterns.</p> </li> <li> <p>Smart Mode Selection: Auto-mode intelligently chooses sync vs async based on task complexity and requirements.</p> </li> </ol>"},{"location":"#hello-world-example","title":"Hello World Example","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n# Define specialized subagents\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics and gathers information\",\n        instructions=\"You are a research assistant. Investigate thoroughly.\",\n    ),\n]\n\n# Create toolset and agent\ntoolset = create_subagent_toolset(subagents=subagents)\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"You can delegate tasks to specialized subagents.\",\n)\n\n# Run the agent\nresult = agent.run_sync(\"Research Python async patterns\", deps=Deps())\nprint(result.output)\n</code></pre>"},{"location":"#core-features","title":"Core Features","text":"Feature Description Dual-Mode Execution Run tasks sync (blocking) or async (background) Auto-Mode Selection Intelligent mode selection based on task characteristics Nested Subagents Subagents can spawn their own subagents Runtime Agent Creation Create specialized agents on-the-fly Parent-Child Q&amp;A Subagents can ask parent for clarification Task Cancellation Soft and hard cancellation support Pluggable Message Bus Extensible communication layer"},{"location":"#available-tools","title":"Available Tools","text":"<p>When you add the subagent toolset, your agent gets these tools:</p> Tool Description <code>task</code> Delegate a task to a subagent (sync, async, or auto) <code>check_task</code> Check status and get result of a background task <code>answer_subagent</code> Answer a question from a blocked subagent <code>list_active_tasks</code> List all running background tasks <code>soft_cancel_task</code> Request cooperative cancellation <code>hard_cancel_task</code> Immediately cancel a task"},{"location":"#part-of-the-pydantic-ai-ecosystem","title":"Part of the Pydantic AI Ecosystem","text":"<p>Subagents for Pydantic AI is part of a modular ecosystem:</p> Package Description Pydantic Deep Agents Full agent framework (uses this library) pydantic-ai-backend File storage and Docker sandbox backends pydantic-ai-todo Task planning toolset summarization-pydantic-ai Context management processors"},{"location":"#installation","title":"Installation","text":"Bash<pre><code>pip install subagents-pydantic-ai\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Get started in minutes</li> <li>Core Concepts - Learn about subagents, toolsets, and types</li> <li>Examples - See subagents in action</li> <li>API Reference - Complete API documentation</li> </ul> <p> <sub>Built with \u2764\ufe0f by vstorm-co</sub> </p>"},{"location":"getting-help/","title":"Getting Help","text":""},{"location":"getting-help/#documentation","title":"Documentation","text":"<p>This documentation covers all aspects of using Subagents for Pydantic AI:</p> <ul> <li>Installation - Getting started</li> <li>Core Concepts - Understanding the fundamentals</li> <li>Examples - Practical code examples</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-help/#github-issues","title":"GitHub Issues","text":"<p>For bug reports and feature requests, please use GitHub Issues.</p> <p>When reporting a bug, please include:</p> <ol> <li>Python version: <code>python --version</code></li> <li>Package version: <code>pip show subagents-pydantic-ai</code></li> <li>Minimal reproducible example</li> <li>Full error traceback</li> </ol>"},{"location":"getting-help/#github-discussions","title":"GitHub Discussions","text":"<p>For questions and discussions, use GitHub Discussions.</p>"},{"location":"getting-help/#related-projects","title":"Related Projects","text":"<p>If your question is about the broader ecosystem:</p> <ul> <li>Pydantic AI - The foundation</li> <li>Pydantic Deep Agents - Full agent framework</li> <li>pydantic-ai-backend - File storage backends</li> </ul>"},{"location":"getting-help/#contributing","title":"Contributing","text":"<p>We welcome contributions! See CONTRIBUTING.md for guidelines.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>uv (recommended) or pip</li> </ul>"},{"location":"installation/#install-with-uv-recommended","title":"Install with uv (recommended)","text":"Bash<pre><code>uv add subagents-pydantic-ai\n</code></pre>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"Bash<pre><code>pip install subagents-pydantic-ai\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The library has minimal dependencies:</p> <ul> <li><code>pydantic&gt;=2.0</code> - Data validation</li> <li><code>pydantic-ai-slim&gt;=0.1.0</code> - Core agent framework</li> </ul>"},{"location":"installation/#environment-setup","title":"Environment Setup","text":""},{"location":"installation/#api-key","title":"API Key","text":"<p>Subagents for Pydantic AI uses Pydantic AI which supports multiple model providers. Set your API key:</p> OpenAIAnthropicGoogle Bash<pre><code>export OPENAI_API_KEY=your-api-key\n</code></pre> Bash<pre><code>export ANTHROPIC_API_KEY=your-api-key\n</code></pre> Bash<pre><code>export GOOGLE_API_KEY=your-api-key\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n# Create a simple subagent\nsubagents = [\n    SubAgentConfig(\n        name=\"greeter\",\n        description=\"Says hello\",\n        instructions=\"You are a friendly greeter. Say hello!\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\nagent = Agent(\n    \"openai:gpt-4o-mini\",\n    deps_type=Deps,\n    toolsets=[toolset],\n)\n\nresult = agent.run_sync(\"Say hello using the greeter subagent\", deps=Deps())\nprint(result.output)\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>If you get import errors, ensure you have the correct Python version:</p> Bash<pre><code>python --version  # Should be 3.10+\n</code></pre>"},{"location":"installation/#api-key-not-found","title":"API Key Not Found","text":"<p>Make sure your API key is set in the environment:</p> Bash<pre><code>echo $OPENAI_API_KEY\n</code></pre>"},{"location":"installation/#type-errors","title":"Type Errors","text":"<p>If you're using strict type checking, ensure you have <code>typing_extensions</code> installed (it's included with pydantic):</p> Bash<pre><code>pip install typing_extensions\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Learn the fundamentals</li> <li>Basic Usage Example - Your first subagent</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"advanced/cancellation/","title":"Task Cancellation","text":"<p>Subagents for Pydantic AI provides two cancellation mechanisms: soft cancel and hard cancel.</p>"},{"location":"advanced/cancellation/#soft-cancellation","title":"Soft Cancellation","text":"<p>Soft cancel requests cooperative cancellation. The subagent receives a signal and should stop gracefully.</p> Python<pre><code># Parent agent calls:\nsoft_cancel_task(task_id=\"abc123\")\n</code></pre>"},{"location":"advanced/cancellation/#how-it-works","title":"How It Works","text":"<ol> <li>Parent calls <code>soft_cancel_task()</code></li> <li>A <code>CANCEL_REQUEST</code> message is sent to the subagent</li> <li>Subagent should check for cancellation and stop gracefully</li> <li>Subagent returns partial results or cancellation acknowledgment</li> <li>Task status becomes <code>CANCELLED</code></li> </ol>"},{"location":"advanced/cancellation/#when-to-use","title":"When to Use","text":"<ul> <li>Task is taking too long</li> <li>Requirements have changed</li> <li>Parent wants to try a different approach</li> <li>Graceful shutdown needed</li> </ul>"},{"location":"advanced/cancellation/#hard-cancellation","title":"Hard Cancellation","text":"<p>Hard cancel forces immediate termination.</p> Python<pre><code># Parent agent calls:\nhard_cancel_task(task_id=\"abc123\")\n</code></pre>"},{"location":"advanced/cancellation/#how-it-works_1","title":"How It Works","text":"<ol> <li>Parent calls <code>hard_cancel_task()</code></li> <li>Task is immediately terminated</li> <li>No cleanup or partial results</li> <li>Task status becomes <code>CANCELLED</code></li> </ol>"},{"location":"advanced/cancellation/#when-to-use_1","title":"When to Use","text":"<ul> <li>Soft cancel didn't work</li> <li>Urgent need to stop</li> <li>Task is stuck or unresponsive</li> <li>Resource constraints</li> </ul> <p>Use with Caution</p> <p>Hard cancellation may leave resources in an inconsistent state. Prefer soft cancellation when possible.</p>"},{"location":"advanced/cancellation/#implementing-cancellation-handling","title":"Implementing Cancellation Handling","text":"<p>Guide subagents to handle cancellation gracefully:</p> Python<pre><code>SubAgentConfig(\n    name=\"researcher\",\n    instructions=\"\"\"You are a research assistant.\n\n## Cancellation Handling\n\nIf you receive a cancellation request:\n1. Stop your current work\n2. Save any partial results\n3. Return what you have with a note that work was cancelled\n\nExample response for cancelled task:\n\"Research was cancelled. Partial findings:\n- Found 3 relevant sources\n- Initial analysis suggests [...]\n- Further investigation was not completed\"\n\"\"\",\n)\n</code></pre>"},{"location":"advanced/cancellation/#cancellation-states","title":"Cancellation States","text":"State Description <code>PENDING</code> Can be cancelled (never started) <code>RUNNING</code> Can be cancelled (soft or hard) <code>WAITING_FOR_ANSWER</code> Can be cancelled <code>COMPLETED</code> Cannot be cancelled (already done) <code>FAILED</code> Cannot be cancelled (already done) <code>CANCELLED</code> Already cancelled"},{"location":"advanced/cancellation/#example-cancellation-workflow","title":"Example: Cancellation Workflow","text":"Python<pre><code># Start a long-running task\ntask(\n    description=\"Comprehensive market research\",\n    subagent_type=\"researcher\",\n    mode=\"async\",\n)\n# Returns: \"Task started with ID: research-123\"\n\n# Check progress\ncheck_task(task_id=\"research-123\")\n# Returns: \"Task is running\"\n\n# Decide to cancel\nsoft_cancel_task(task_id=\"research-123\")\n# Returns: \"Cancellation requested for task research-123\"\n\n# Check final status\ncheck_task(task_id=\"research-123\")\n# Returns: \"Task cancelled. Partial results: [...]\"\n</code></pre>"},{"location":"advanced/cancellation/#handling-multiple-tasks","title":"Handling Multiple Tasks","text":"<p>When cancelling multiple tasks:</p> Python<pre><code># List active tasks\nlist_active_tasks()\n# Returns list of task IDs and statuses\n\n# Cancel specific tasks\nsoft_cancel_task(task_id=\"task-a\")\nsoft_cancel_task(task_id=\"task-b\")\n\n# Or hard cancel if needed\nhard_cancel_task(task_id=\"task-c\")\n</code></pre>"},{"location":"advanced/cancellation/#best-practices","title":"Best Practices","text":""},{"location":"advanced/cancellation/#1-prefer-soft-cancellation","title":"1. Prefer Soft Cancellation","text":"<p>Always try soft cancel first:</p> Python<pre><code># First attempt\nsoft_cancel_task(task_id=\"abc123\")\n\n# Wait and check\ncheck_task(task_id=\"abc123\")\n\n# Only if still running after reasonable time\nhard_cancel_task(task_id=\"abc123\")\n</code></pre>"},{"location":"advanced/cancellation/#2-design-for-cancellation","title":"2. Design for Cancellation","text":"<p>Structure subagent work so it can be stopped at checkpoints:</p> Python<pre><code>instructions=\"\"\"\nWork in phases:\n1. Gather sources (checkpoint)\n2. Initial analysis (checkpoint)\n3. Deep dive (checkpoint)\n4. Synthesis\n\nAt each checkpoint, check for cancellation and save progress.\nIf cancelled, return results from completed phases.\n\"\"\"\n</code></pre>"},{"location":"advanced/cancellation/#3-communicate-cancellation-clearly","title":"3. Communicate Cancellation Clearly","text":"<p>Return useful information when cancelled:</p> Python<pre><code>instructions=\"\"\"\nIf cancelled, return:\n- What was completed\n- What was in progress\n- What wasn't started\n- Any preliminary findings\n\"\"\"\n</code></pre>"},{"location":"advanced/cancellation/#next-steps","title":"Next Steps","text":"<ul> <li>Dynamic Agents - Runtime agent creation</li> <li>Message Bus - Communication layer</li> </ul>"},{"location":"advanced/dynamic-agents/","title":"Dynamic Agent Creation","text":"<p>Create specialized agents at runtime using the agent factory toolset.</p>"},{"location":"advanced/dynamic-agents/#overview","title":"Overview","text":"<p>While pre-configured subagents cover most use cases, sometimes you need to create agents dynamically:</p> <ul> <li>User requests a specialist for an unexpected domain</li> <li>Task requires a unique combination of capabilities</li> <li>Experimentation with different agent configurations</li> </ul>"},{"location":"advanced/dynamic-agents/#agent-factory-toolset","title":"Agent Factory Toolset","text":"<p>Add dynamic creation capabilities:</p> Python<pre><code>from subagents_pydantic_ai import (\n    create_subagent_toolset,\n    create_agent_factory_toolset,\n    DynamicAgentRegistry,\n)\n\nregistry = DynamicAgentRegistry()\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[\n        create_subagent_toolset(subagents=base_subagents),\n        create_agent_factory_toolset(\n            registry=registry,\n            allowed_models=[\"openai:gpt-4o\", \"openai:gpt-4o-mini\"],\n            max_agents=5,\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>registry</code> <code>DynamicAgentRegistry</code> Required Registry for created agents <code>allowed_models</code> <code>list[str]</code> All Models agents can use <code>max_agents</code> <code>int</code> <code>10</code> Maximum dynamic agents <code>default_model</code> <code>str \\| None</code> <code>None</code> Default model for new agents"},{"location":"advanced/dynamic-agents/#dynamicagentregistry","title":"DynamicAgentRegistry","text":"<p>The <code>DynamicAgentRegistry</code> tracks dynamically created agents. It stores the <code>Agent</code> instance, the <code>SubAgentConfig</code>, and a <code>CompiledSubAgent</code> for each registered agent.</p> Python<pre><code>from subagents_pydantic_ai import DynamicAgentRegistry\n\nregistry = DynamicAgentRegistry()\n\n# Check registered agents\nagents = registry.list_agents()\n\n# Get a specific agent\nagent = registry.get(\"custom-analyst\")\n\n# Remove an agent\nregistry.remove(\"custom-analyst\")\n</code></pre>"},{"location":"advanced/dynamic-agents/#registry-lifecycle","title":"Registry Lifecycle","text":"<p>The lifecycle of a dynamically created agent follows four stages:</p> Text Only<pre><code>Creation \u2192 Registration \u2192 Usage \u2192 Removal\n</code></pre>"},{"location":"advanced/dynamic-agents/#1-creation","title":"1. Creation","text":"<p>An agent is created when the parent calls <code>create_agent()</code> through the factory toolset. The factory validates the name, model, and capabilities, then builds a <code>pydantic-ai</code> <code>Agent</code> instance.</p>"},{"location":"advanced/dynamic-agents/#2-registration","title":"2. Registration","text":"<p>The agent, its <code>SubAgentConfig</code>, and a <code>CompiledSubAgent</code> wrapper are stored together in the registry via <code>registry.register(config, agent)</code>. At this point the agent becomes discoverable by the <code>task()</code> tool.</p> Python<pre><code># Internal flow (handled by create_agent_factory_toolset):\nconfig = SubAgentConfig(name=\"rust-expert\", description=\"...\", instructions=\"...\")\nagent = Agent(\"openai:gpt-4.1\", system_prompt=config[\"instructions\"])\nregistry.register(config, agent)\n</code></pre>"},{"location":"advanced/dynamic-agents/#3-usage","title":"3. Usage","text":"<p>Once registered, the <code>task()</code> tool can delegate work to the dynamic agent by name. The toolset looks up the agent in the compiled dict first, then falls back to the registry:</p> Python<pre><code># Parent agent calls:\ntask(description=\"Review this Rust code\", subagent_type=\"rust-expert\", mode=\"sync\")\n</code></pre>"},{"location":"advanced/dynamic-agents/#4-removal","title":"4. Removal","text":"<p>When a dynamic agent is no longer needed, the parent calls <code>remove_agent()</code> through the factory toolset. This removes all three entries (agent, config, compiled) from the registry:</p> Python<pre><code># Parent agent calls:\nremove_agent(name=\"rust-expert\")\n</code></pre>"},{"location":"advanced/dynamic-agents/#registry-methods","title":"Registry Methods","text":"Method Returns Description <code>register(config, agent)</code> <code>None</code> Register a new agent (raises <code>ValueError</code> if name exists or limit reached) <code>get(name)</code> <code>Agent \\| None</code> Get the <code>Agent</code> instance by name <code>get_config(name)</code> <code>SubAgentConfig \\| None</code> Get the configuration by name <code>get_compiled(name)</code> <code>CompiledSubAgent \\| None</code> Get the compiled wrapper by name <code>remove(name)</code> <code>bool</code> Remove an agent, returns <code>True</code> if found <code>list_agents()</code> <code>list[str]</code> Get all registered agent names <code>list_configs()</code> <code>list[SubAgentConfig]</code> Get all configurations <code>list_compiled()</code> <code>list[CompiledSubAgent]</code> Get all compiled agents <code>exists(name)</code> <code>bool</code> Check if an agent is registered <code>count()</code> <code>int</code> Number of registered agents <code>clear()</code> <code>None</code> Remove all agents <code>get_summary()</code> <code>str</code> Formatted summary of all agents"},{"location":"advanced/dynamic-agents/#integration-with-pydantic-deep","title":"Integration with pydantic-deep","text":"<p>When using subagents with <code>pydantic-deep</code>, pass the registry to both the subagent toolset and the agent factory toolset so they share state:</p> Python<pre><code>from pydantic_ai import Agent\nfrom subagents_pydantic_ai import (\n    create_subagent_toolset,\n    create_agent_factory_toolset,\n    DynamicAgentRegistry,\n    SubAgentConfig,\n)\n\n# Shared registry\nregistry = DynamicAgentRegistry(max_agents=5)\n\n# Pre-configured subagents\nbase_subagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"You are a research assistant.\",\n    ),\n]\n\n# The subagent toolset receives the registry so task() can find dynamic agents\nsubagent_toolset = create_subagent_toolset(\n    subagents=base_subagents,\n    registry=registry,\n)\n\n# The factory toolset uses the same registry to register new agents\nfactory_toolset = create_agent_factory_toolset(\n    registry=registry,\n    allowed_models=[\"openai:gpt-4.1\", \"openai:gpt-4o-mini\"],\n    max_agents=5,\n)\n\nagent = Agent(\n    \"openai:gpt-4.1\",\n    deps_type=Deps,\n    toolsets=[subagent_toolset, factory_toolset],\n)\n</code></pre> <p>With this setup:</p> <ul> <li>The parent can delegate to pre-configured subagents (\"researcher\") via <code>task()</code></li> <li>The parent can create new subagents at runtime via <code>create_agent()</code></li> <li>Newly created agents are immediately available to <code>task()</code> because both toolsets share the same <code>registry</code> instance</li> <li>When the parent removes a dynamic agent, it is no longer discoverable by <code>task()</code></li> </ul>"},{"location":"advanced/dynamic-agents/#creating-agents-at-runtime","title":"Creating Agents at Runtime","text":"<p>The parent agent can create new subagents:</p> Python<pre><code># Parent agent calls:\ncreate_agent(\n    name=\"rust-expert\",\n    description=\"Expert in Rust programming\",\n    instructions=\"You are a Rust programming expert. Help with Rust code.\",\n    model=\"openai:gpt-4o\",\n)\n# Returns: \"Created agent 'rust-expert'\"\n\n# Now the agent can be used:\ntask(\n    description=\"Review this Rust code for memory safety\",\n    subagent_type=\"rust-expert\",\n    mode=\"sync\",\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#use-cases","title":"Use Cases","text":""},{"location":"advanced/dynamic-agents/#domain-specific-experts","title":"Domain-Specific Experts","text":"<p>Create experts for domains not covered by pre-configured agents:</p> Python<pre><code># User asks about a niche topic\n# Parent creates a specialist:\ncreate_agent(\n    name=\"kubernetes-expert\",\n    description=\"Expert in Kubernetes and container orchestration\",\n    instructions=\"\"\"You are a Kubernetes expert.\n    Help with:\n    - Deployment configurations\n    - Service mesh setup\n    - Troubleshooting pods\n    - Resource optimization\n    \"\"\",\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#language-specific-helpers","title":"Language-Specific Helpers","text":"<p>Create helpers for different programming languages:</p> Python<pre><code>create_agent(\n    name=\"go-helper\",\n    description=\"Go programming assistant\",\n    instructions=\"You help with Go programming. Follow Go idioms and best practices.\",\n)\n\ncreate_agent(\n    name=\"swift-helper\",\n    description=\"Swift/iOS development assistant\",\n    instructions=\"You help with Swift and iOS development.\",\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#persona-based-agents","title":"Persona-Based Agents","text":"<p>Create agents with specific personas:</p> Python<pre><code>create_agent(\n    name=\"devil-advocate\",\n    description=\"Challenges ideas constructively\",\n    instructions=\"\"\"You play devil's advocate.\n    When given an idea or plan:\n    - Find potential weaknesses\n    - Challenge assumptions\n    - Suggest alternative approaches\n    - Be constructive, not dismissive\n    \"\"\",\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#limits-and-security","title":"Limits and Security","text":""},{"location":"advanced/dynamic-agents/#model-restrictions","title":"Model Restrictions","text":"<p>Only allow specific models:</p> Python<pre><code>create_agent_factory_toolset(\n    registry=registry,\n    allowed_models=[\"openai:gpt-4o-mini\"],  # Only allow mini\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#agent-limits","title":"Agent Limits","text":"<p>Prevent unlimited agent creation:</p> Python<pre><code>create_agent_factory_toolset(\n    registry=registry,\n    max_agents=3,  # Maximum 3 dynamic agents\n)\n</code></pre> <p>After reaching the limit, creating new agents will fail until existing ones are removed.</p>"},{"location":"advanced/dynamic-agents/#naming-conflicts","title":"Naming Conflicts","text":"<p>Dynamic agents cannot override pre-configured agents:</p> Python<pre><code># If \"researcher\" is pre-configured:\ncreate_agent(name=\"researcher\", ...)\n# Returns: \"Error: Agent 'researcher' already exists\"\n</code></pre>"},{"location":"advanced/dynamic-agents/#best-practices","title":"Best Practices","text":""},{"location":"advanced/dynamic-agents/#1-use-pre-configured-when-possible","title":"1. Use Pre-Configured When Possible","text":"<p>Dynamic creation has overhead. Pre-configure common agents:</p> Python<pre><code># Good: Pre-configure known specialists\nsubagents = [\n    SubAgentConfig(name=\"researcher\", ...),\n    SubAgentConfig(name=\"writer\", ...),\n    SubAgentConfig(name=\"coder\", ...),\n]\n\n# Use dynamic only for truly unexpected needs\n</code></pre>"},{"location":"advanced/dynamic-agents/#2-clear-naming","title":"2. Clear Naming","text":"<p>Use descriptive names for dynamic agents:</p> Python<pre><code># Good\ncreate_agent(name=\"react-typescript-expert\", ...)\n\n# Bad\ncreate_agent(name=\"agent1\", ...)\n</code></pre>"},{"location":"advanced/dynamic-agents/#3-focused-instructions","title":"3. Focused Instructions","text":"<p>Keep dynamic agent instructions focused:</p> Python<pre><code># Good: Focused\ncreate_agent(\n    name=\"sql-optimizer\",\n    instructions=\"You optimize SQL queries for PostgreSQL.\",\n)\n\n# Bad: Too broad\ncreate_agent(\n    name=\"helper\",\n    instructions=\"You help with everything.\",\n)\n</code></pre>"},{"location":"advanced/dynamic-agents/#next-steps","title":"Next Steps","text":"<ul> <li>Message Bus - Communication layer</li> <li>Examples - Working examples</li> </ul>"},{"location":"advanced/execution-modes/","title":"Execution Modes","text":"<p>Subagents for Pydantic AI supports three execution modes: sync, async, and auto.</p>"},{"location":"advanced/execution-modes/#overview","title":"Overview","text":"Mode Behavior Use Case <code>sync</code> Block until complete Quick tasks, immediate results needed <code>async</code> Run in background Long tasks, parallel execution <code>auto</code> System decides Let the library choose optimally"},{"location":"advanced/execution-modes/#sync-mode","title":"Sync Mode","text":"<p>In sync mode, the parent agent waits for the subagent to complete before continuing.</p> Python<pre><code># Parent agent calls:\ntask(\n    description=\"Calculate the sum of 1 to 100\",\n    subagent_type=\"calculator\",\n    mode=\"sync\",\n)\n# Blocks here until done\n# Returns: \"The sum is 5050\"\n</code></pre> <p>Best for:</p> <ul> <li>Quick calculations</li> <li>When result is needed immediately</li> <li>Back-and-forth communication</li> <li>Simple transformations</li> </ul>"},{"location":"advanced/execution-modes/#async-mode","title":"Async Mode","text":"<p>In async mode, the task runs in the background and returns immediately with a task ID.</p> Python<pre><code># Parent agent calls:\ntask(\n    description=\"Research the history of Python\",\n    subagent_type=\"researcher\",\n    mode=\"async\",\n)\n# Returns immediately: \"Task started with ID: abc123\"\n\n# Later, check status:\ncheck_task(task_id=\"abc123\")\n# Returns status, result if complete, or pending question\n</code></pre> <p>Best for:</p> <ul> <li>Long-running research</li> <li>Parallel tasks</li> <li>When parent can do other work meanwhile</li> <li>Complex analysis</li> </ul>"},{"location":"advanced/execution-modes/#task-lifecycle","title":"Task Lifecycle","text":"Text Only<pre><code>PENDING \u2192 RUNNING \u2192 COMPLETED\n                 \u2198 WAITING_FOR_ANSWER \u2192 RUNNING \u2192 ...\n                 \u2198 FAILED\n                 \u2198 CANCELLED\n</code></pre>"},{"location":"advanced/execution-modes/#auto-mode","title":"Auto Mode","text":"<p>Auto mode uses heuristics to decide between sync and async.</p> Python<pre><code># Parent agent calls:\ntask(\n    description=\"Analyze this dataset\",\n    subagent_type=\"analyst\",\n    mode=\"auto\",\n)\n# System decides based on task characteristics\n</code></pre>"},{"location":"advanced/execution-modes/#decision-logic","title":"Decision Logic","text":"<p>The <code>decide_execution_mode()</code> function considers the following in order of priority:</p> <ol> <li>Explicit override: If <code>force_mode</code> is set (not \"auto\"), use it directly</li> <li>Config preference: Subagent's <code>preferred_mode</code> setting (if not \"auto\")</li> <li>User context: Tasks requiring user context \u2192 sync</li> <li>Clarification + time-sensitive: May need clarification AND is time-sensitive \u2192 sync</li> <li>Complexity + independence: Complex tasks that can run independently \u2192 async</li> <li>Simplicity: Simple tasks \u2192 sync</li> <li>Independence fallback: Moderate complexity that can run independently \u2192 async</li> <li>Final default: Everything else \u2192 sync</li> </ol> Python<pre><code>from subagents_pydantic_ai import decide_execution_mode, TaskCharacteristics\n\ncharacteristics = TaskCharacteristics(\n    estimated_complexity=\"complex\",\n    requires_user_context=False,\n    is_time_sensitive=False,\n    can_run_independently=True,\n    may_need_clarification=False,\n)\n\nmode = decide_execution_mode(characteristics, config)\n# Returns \"async\" for complex independent tasks\n</code></pre>"},{"location":"advanced/execution-modes/#taskcharacteristics-fields","title":"TaskCharacteristics Fields","text":"<p>The <code>TaskCharacteristics</code> dataclass holds the properties used for auto-mode decision-making:</p> Field Type Default Description <code>estimated_complexity</code> <code>\"simple\" \\| \"moderate\" \\| \"complex\"</code> <code>\"moderate\"</code> Expected task complexity level <code>requires_user_context</code> <code>bool</code> <code>False</code> Whether task needs ongoing user interaction <code>is_time_sensitive</code> <code>bool</code> <code>False</code> Whether quick response is important <code>can_run_independently</code> <code>bool</code> <code>True</code> Whether task can complete without further input <code>may_need_clarification</code> <code>bool</code> <code>False</code> Whether task might need clarifying questions <p>These fields can be set explicitly when calling the <code>task()</code> tool, or they are inferred from the subagent's <code>SubAgentConfig</code> at runtime.</p>"},{"location":"advanced/execution-modes/#auto-mode-decision-examples","title":"Auto-Mode Decision Examples","text":"<p>The following table shows how different combinations of <code>TaskCharacteristics</code> resolve to sync or async:</p> Scenario Complexity User Context Time Sensitive Independent Clarification Result Quick lookup <code>simple</code> <code>False</code> <code>True</code> <code>True</code> <code>False</code> sync Deep research <code>complex</code> <code>False</code> <code>False</code> <code>True</code> <code>False</code> async Interactive editing <code>moderate</code> <code>True</code> <code>False</code> <code>False</code> <code>True</code> sync Background analysis <code>moderate</code> <code>False</code> <code>False</code> <code>True</code> <code>False</code> async Urgent clarification <code>moderate</code> <code>False</code> <code>True</code> <code>True</code> <code>True</code> sync Complex but dependent <code>complex</code> <code>False</code> <code>False</code> <code>False</code> <code>True</code> sync"},{"location":"advanced/execution-modes/#example-1-auto-picks-sync-for-a-simple-task","title":"Example 1: Auto picks sync for a simple task","text":"Python<pre><code># Simple question answering - auto resolves to sync\ntask(\n    description=\"What is the capital of France?\",\n    subagent_type=\"general-purpose\",\n    mode=\"auto\",\n    complexity=\"simple\",\n)\n# Auto-mode sees: simple complexity \u2192 sync\n# Parent gets the answer immediately\n</code></pre>"},{"location":"advanced/execution-modes/#example-2-auto-picks-async-for-complex-independent-work","title":"Example 2: Auto picks async for complex independent work","text":"Python<pre><code># Deep research - auto resolves to async\ntask(\n    description=\"Analyze the codebase architecture and produce a report\",\n    subagent_type=\"researcher\",\n    mode=\"auto\",\n    complexity=\"complex\",\n)\n# Auto-mode sees: complex + can_run_independently \u2192 async\n# Returns task handle immediately, parent continues working\n</code></pre>"},{"location":"advanced/execution-modes/#example-3-auto-picks-sync-when-user-context-is-needed","title":"Example 3: Auto picks sync when user context is needed","text":"Python<pre><code># Task needing ongoing user interaction - auto resolves to sync\ntask(\n    description=\"Help me refine this paragraph\",\n    subagent_type=\"editor\",\n    mode=\"auto\",\n    requires_user_context=True,\n)\n# Auto-mode sees: requires_user_context=True \u2192 sync\n# Ensures interactive back-and-forth is possible\n</code></pre>"},{"location":"advanced/execution-modes/#example-4-auto-picks-sync-for-time-sensitive-tasks-that-may-need-clarification","title":"Example 4: Auto picks sync for time-sensitive tasks that may need clarification","text":"Python<pre><code># Urgent task that might need questions - auto resolves to sync\ntask(\n    description=\"Fix this production bug quickly\",\n    subagent_type=\"coder\",\n    mode=\"auto\",\n    complexity=\"moderate\",\n    may_need_clarification=True,\n)\n# Auto-mode sees: may_need_clarification + is_time_sensitive \u2192 sync\n# (assuming the subagent config has is_time_sensitive context)\n</code></pre>"},{"location":"advanced/execution-modes/#example-5-auto-picks-async-for-moderate-independent-work","title":"Example 5: Auto picks async for moderate independent work","text":"Python<pre><code># Moderate task that can run alone - auto resolves to async\ntask(\n    description=\"Generate test cases for the user service\",\n    subagent_type=\"coder\",\n    mode=\"auto\",\n    complexity=\"moderate\",\n)\n# Auto-mode sees: moderate + can_run_independently \u2192 async\n# Parent can start other tasks in parallel\n</code></pre>"},{"location":"advanced/execution-modes/#configuring-auto-mode-hints","title":"Configuring Auto-Mode Hints","text":"<p>Guide auto-mode with subagent configuration. The <code>preferred_mode</code>, <code>typical_complexity</code>, and <code>typically_needs_context</code> fields in <code>SubAgentConfig</code> provide hints to the auto-mode decision logic:</p> Python<pre><code>SubAgentConfig(\n    name=\"deep-researcher\",\n    description=\"Does thorough research\",\n    instructions=\"...\",\n    preferred_mode=\"async\",  # Hint: prefer async\n    typical_complexity=\"complex\",  # Usually complex tasks\n    typically_needs_context=False,  # Can work independently\n)\n</code></pre> <p>When a subagent has <code>preferred_mode</code> set to \"sync\" or \"async\", auto-mode respects that preference before evaluating task characteristics. The <code>typical_complexity</code> value is used as a fallback when the caller does not pass an explicit <code>complexity</code> parameter to <code>task()</code>.</p> Python<pre><code># This subagent always runs sync due to preferred_mode\nSubAgentConfig(\n    name=\"quick-helper\",\n    description=\"Answers simple questions instantly\",\n    instructions=\"...\",\n    preferred_mode=\"sync\",  # Always sync, regardless of characteristics\n)\n\n# This subagent lets auto-mode decide but hints at complexity\nSubAgentConfig(\n    name=\"analyst\",\n    description=\"Performs data analysis\",\n    instructions=\"...\",\n    preferred_mode=\"auto\",  # Let auto decide\n    typical_complexity=\"complex\",  # Hint: tasks are usually complex\n    typically_needs_context=False,  # Hint: can work independently\n)\n</code></pre>"},{"location":"advanced/execution-modes/#managing-async-tasks","title":"Managing Async Tasks","text":""},{"location":"advanced/execution-modes/#checking-status","title":"Checking Status","text":"Python<pre><code># Agent calls:\ncheck_task(task_id=\"abc123\")\n</code></pre> <p>Returns different responses based on status:</p> Status Response <code>PENDING</code> \"Task is queued\" <code>RUNNING</code> \"Task is running\" <code>WAITING_FOR_ANSWER</code> \"Task needs answer: [question]\" <code>COMPLETED</code> \"Task complete: [result]\" <code>FAILED</code> \"Task failed: [error]\" <code>CANCELLED</code> \"Task was cancelled\""},{"location":"advanced/execution-modes/#listing-active-tasks","title":"Listing Active Tasks","text":"Python<pre><code># Agent calls:\nlist_active_tasks()\n</code></pre> <p>Returns a list of all non-completed tasks with their status.</p>"},{"location":"advanced/execution-modes/#answering-questions","title":"Answering Questions","text":"<p>If a subagent asks a question (when <code>can_ask_questions=True</code>):</p> Python<pre><code># Agent calls:\nanswer_subagent(task_id=\"abc123\", answer=\"Use PostgreSQL\")\n</code></pre> <p>The subagent continues with the provided answer.</p>"},{"location":"advanced/execution-modes/#cancellation","title":"Cancellation","text":"<p>Soft cancel - request cooperative cancellation:</p> Python<pre><code>soft_cancel_task(task_id=\"abc123\")\n</code></pre> <p>The subagent receives a cancellation request and should stop gracefully.</p> <p>Hard cancel - immediate termination:</p> Python<pre><code>hard_cancel_task(task_id=\"abc123\")\n</code></pre> <p>Forces immediate stop, may leave resources in inconsistent state.</p>"},{"location":"advanced/execution-modes/#parallel-execution","title":"Parallel Execution","text":"<p>Run multiple tasks simultaneously:</p> Python<pre><code># Agent's thought process:\n# \"I need to research three topics. I'll start them all in parallel.\"\n\n# Agent calls:\ntask(description=\"Research topic A\", subagent_type=\"researcher\", mode=\"async\")\n# Returns: \"Task started with ID: task-a\"\n\ntask(description=\"Research topic B\", subagent_type=\"researcher\", mode=\"async\")\n# Returns: \"Task started with ID: task-b\"\n\ntask(description=\"Research topic C\", subagent_type=\"researcher\", mode=\"async\")\n# Returns: \"Task started with ID: task-c\"\n\n# Agent does other work...\n\n# Agent checks results:\ncheck_task(task_id=\"task-a\")\ncheck_task(task_id=\"task-b\")\ncheck_task(task_id=\"task-c\")\n</code></pre>"},{"location":"advanced/execution-modes/#best-practices","title":"Best Practices","text":""},{"location":"advanced/execution-modes/#1-use-sync-for-interactive-tasks","title":"1. Use Sync for Interactive Tasks","text":"<p>When you need immediate feedback or multiple rounds of communication:</p> Python<pre><code>SubAgentConfig(\n    name=\"editor\",\n    description=\"Edits text interactively\",\n    instructions=\"...\",\n    preferred_mode=\"sync\",\n)\n</code></pre>"},{"location":"advanced/execution-modes/#2-use-async-for-heavy-work","title":"2. Use Async for Heavy Work","text":"<p>For tasks that take significant time:</p> Python<pre><code>SubAgentConfig(\n    name=\"analyzer\",\n    description=\"Performs deep analysis\",\n    instructions=\"...\",\n    preferred_mode=\"async\",\n    typical_complexity=\"complex\",\n)\n</code></pre>"},{"location":"advanced/execution-modes/#3-let-auto-decide-when-unsure","title":"3. Let Auto Decide When Unsure","text":"<p>If you're not sure which mode is best:</p> Python<pre><code>task(\n    description=\"...\",\n    subagent_type=\"worker\",\n    mode=\"auto\",  # Let the system decide\n)\n</code></pre>"},{"location":"advanced/execution-modes/#next-steps","title":"Next Steps","text":"<ul> <li>Questions - Parent-child communication</li> <li>Cancellation - Managing task lifecycle</li> <li>Examples - Working examples</li> </ul>"},{"location":"advanced/message-bus/","title":"Message Bus","text":"<p>The message bus handles communication between parent agents and subagents. By default, an in-memory bus is used, but you can implement custom buses for distributed systems.</p>"},{"location":"advanced/message-bus/#default-in-memory-bus","title":"Default In-Memory Bus","text":"<p>The library uses <code>InMemoryMessageBus</code> by default:</p> Python<pre><code>from subagents_pydantic_ai import create_subagent_toolset\n\n# Uses InMemoryMessageBus internally\ntoolset = create_subagent_toolset(subagents=subagents)\n</code></pre> <p>This is suitable for:</p> <ul> <li>Single-process applications</li> <li>Development and testing</li> <li>Simple deployments</li> </ul>"},{"location":"advanced/message-bus/#message-types","title":"Message Types","text":"<p>The bus handles these message types:</p> Type Direction Purpose <code>TASK_ASSIGNED</code> Parent \u2192 Subagent New task assignment <code>TASK_UPDATE</code> Subagent \u2192 Parent Progress update <code>TASK_COMPLETED</code> Subagent \u2192 Parent Task finished successfully <code>TASK_FAILED</code> Subagent \u2192 Parent Task failed with error <code>QUESTION</code> Subagent \u2192 Parent Asking for clarification <code>ANSWER</code> Parent \u2192 Subagent Response to question <code>CANCEL_REQUEST</code> Parent \u2192 Subagent Soft cancellation request <code>CANCEL_FORCED</code> Parent \u2192 Subagent Hard cancellation"},{"location":"advanced/message-bus/#agentmessage-structure","title":"AgentMessage Structure","text":"<p>Messages passed through the bus:</p> Python<pre><code>from subagents_pydantic_ai import AgentMessage, MessageType\n\nmessage = AgentMessage(\n    type=MessageType.QUESTION,\n    sender=\"subagent-123\",\n    receiver=\"parent-456\",\n    payload={\"question\": \"Which database should I use?\"},\n    task_id=\"task-789\",\n)\n</code></pre>"},{"location":"advanced/message-bus/#custom-message-bus","title":"Custom Message Bus","text":"<p>To build a custom message bus, implement the <code>MessageBusProtocol</code>. The protocol requires these methods:</p> Method Purpose <code>send(message)</code> Deliver a message to a specific agent <code>ask(sender, receiver, question, task_id, timeout)</code> Send a question and block until an answer arrives <code>answer(original, answer)</code> Reply to a previously received question <code>register_agent(agent_id)</code> Register an agent and return its message queue <code>unregister_agent(agent_id)</code> Remove an agent from the bus <code>get_messages(agent_id, timeout)</code> Retrieve pending messages for an agent"},{"location":"advanced/message-bus/#step-by-step-building-a-redis-message-bus","title":"Step-by-Step: Building a Redis Message Bus","text":"<p>Below is a complete example of implementing a Redis-based message bus. This is useful when parent agents and subagent workers run in separate processes or machines.</p> Python<pre><code>import asyncio\nimport json\nfrom dataclasses import dataclass, field\n\nfrom redis.asyncio import Redis\n\nfrom subagents_pydantic_ai import (\n    MessageBusProtocol,\n    AgentMessage,\n    MessageType,\n)\n\n\n@dataclass\nclass RedisMessageBus:\n    \"\"\"Redis-based message bus for distributed subagent systems.\n\n    Uses Redis pub/sub for real-time message delivery and Redis lists\n    as a fallback queue for messages sent before the receiver subscribes.\n    \"\"\"\n\n    redis_url: str = \"redis://localhost:6379\"\n    _redis: Redis | None = field(default=None, repr=False)\n    _queues: dict[str, asyncio.Queue[AgentMessage]] = field(default_factory=dict)\n    _pending_questions: dict[str, asyncio.Future[AgentMessage]] = field(\n        default_factory=dict\n    )\n    _listeners: dict[str, asyncio.Task[None]] = field(default_factory=dict)\n\n    async def _get_redis(self) -&gt; Redis:\n        if self._redis is None:\n            self._redis = Redis.from_url(self.redis_url, decode_responses=True)\n        return self._redis\n\n    def _channel(self, agent_id: str) -&gt; str:\n        return f\"subagent:messages:{agent_id}\"\n\n    def _serialize(self, message: AgentMessage) -&gt; str:\n        return json.dumps({\n            \"type\": message.type.value,\n            \"sender\": message.sender,\n            \"receiver\": message.receiver,\n            \"payload\": message.payload,\n            \"task_id\": message.task_id,\n            \"id\": message.id,\n            \"correlation_id\": message.correlation_id,\n        })\n\n    def _deserialize(self, data: str) -&gt; AgentMessage:\n        d = json.loads(data)\n        return AgentMessage(\n            type=MessageType(d[\"type\"]),\n            sender=d[\"sender\"],\n            receiver=d[\"receiver\"],\n            payload=d[\"payload\"],\n            task_id=d[\"task_id\"],\n            id=d.get(\"id\", \"\"),\n            correlation_id=d.get(\"correlation_id\"),\n        )\n\n    # ---- MessageBusProtocol methods ----\n\n    async def send(self, message: AgentMessage) -&gt; None:\n        \"\"\"Publish a message to the receiver's Redis channel.\"\"\"\n        if message.receiver not in self._queues:\n            raise KeyError(f\"Agent '{message.receiver}' is not registered\")\n\n        redis = await self._get_redis()\n        await redis.publish(\n            self._channel(message.receiver),\n            self._serialize(message),\n        )\n\n    async def ask(\n        self,\n        sender: str,\n        receiver: str,\n        question: object,\n        task_id: str,\n        timeout: float = 30.0,\n    ) -&gt; AgentMessage:\n        \"\"\"Send a question and wait for the correlated answer.\"\"\"\n        import uuid\n\n        correlation_id = str(uuid.uuid4())\n\n        loop = asyncio.get_event_loop()\n        future: asyncio.Future[AgentMessage] = loop.create_future()\n        self._pending_questions[correlation_id] = future\n\n        try:\n            msg = AgentMessage(\n                type=MessageType.QUESTION,\n                sender=sender,\n                receiver=receiver,\n                payload=question,\n                task_id=task_id,\n                correlation_id=correlation_id,\n            )\n            await self.send(msg)\n            return await asyncio.wait_for(future, timeout=timeout)\n        finally:\n            self._pending_questions.pop(correlation_id, None)\n\n    async def answer(self, original: AgentMessage, answer: object) -&gt; None:\n        \"\"\"Answer a previously received question.\"\"\"\n        response = AgentMessage(\n            type=MessageType.ANSWER,\n            sender=original.receiver,\n            receiver=original.sender,\n            payload=answer,\n            task_id=original.task_id,\n            correlation_id=original.correlation_id,\n        )\n\n        if (\n            original.correlation_id\n            and original.correlation_id in self._pending_questions\n        ):\n            future = self._pending_questions[original.correlation_id]\n            if not future.done():\n                future.set_result(response)\n        else:\n            await self.send(response)\n\n    def register_agent(self, agent_id: str) -&gt; asyncio.Queue[AgentMessage]:\n        \"\"\"Register an agent and start listening on its Redis channel.\"\"\"\n        if agent_id in self._queues:\n            raise ValueError(f\"Agent '{agent_id}' is already registered\")\n\n        queue: asyncio.Queue[AgentMessage] = asyncio.Queue()\n        self._queues[agent_id] = queue\n\n        # Start a background listener for this agent's channel\n        self._listeners[agent_id] = asyncio.create_task(\n            self._listen(agent_id, queue)\n        )\n        return queue\n\n    def unregister_agent(self, agent_id: str) -&gt; None:\n        \"\"\"Unregister an agent and stop its listener.\"\"\"\n        self._queues.pop(agent_id, None)\n        listener = self._listeners.pop(agent_id, None)\n        if listener and not listener.done():\n            listener.cancel()\n\n    async def get_messages(\n        self,\n        agent_id: str,\n        timeout: float = 0.0,\n    ) -&gt; list[AgentMessage]:\n        \"\"\"Get pending messages from the local queue.\"\"\"\n        if agent_id not in self._queues:\n            raise KeyError(f\"Agent '{agent_id}' is not registered\")\n\n        queue = self._queues[agent_id]\n        messages: list[AgentMessage] = []\n\n        if timeout &gt; 0 and queue.empty():\n            try:\n                msg = await asyncio.wait_for(queue.get(), timeout=timeout)\n                messages.append(msg)\n            except asyncio.TimeoutError:\n                return messages\n\n        while not queue.empty():\n            messages.append(queue.get_nowait())\n\n        return messages\n\n    # ---- Internal helpers ----\n\n    async def _listen(\n        self,\n        agent_id: str,\n        queue: asyncio.Queue[AgentMessage],\n    ) -&gt; None:\n        \"\"\"Subscribe to a Redis channel and forward messages to the queue.\"\"\"\n        redis = await self._get_redis()\n        pubsub = redis.pubsub()\n        await pubsub.subscribe(self._channel(agent_id))\n\n        try:\n            async for raw_message in pubsub.listen():\n                if raw_message[\"type\"] != \"message\":\n                    continue\n                msg = self._deserialize(raw_message[\"data\"])\n\n                # Resolve pending question futures\n                if (\n                    msg.type == MessageType.ANSWER\n                    and msg.correlation_id\n                    and msg.correlation_id in self._pending_questions\n                ):\n                    future = self._pending_questions[msg.correlation_id]\n                    if not future.done():\n                        future.set_result(msg)\n                    continue\n\n                await queue.put(msg)\n        except asyncio.CancelledError:\n            pass\n        finally:\n            await pubsub.unsubscribe(self._channel(agent_id))\n\n    async def close(self) -&gt; None:\n        \"\"\"Clean up all listeners and the Redis connection.\"\"\"\n        for agent_id in list(self._listeners):\n            self.unregister_agent(agent_id)\n        if self._redis:\n            await self._redis.close()\n            self._redis = None\n</code></pre>"},{"location":"advanced/message-bus/#using-the-custom-bus","title":"Using the Custom Bus","text":"<p>Pass your custom bus to <code>create_subagent_toolset()</code> or inject it manually via <code>TaskManager</code>:</p> Python<pre><code>from subagents_pydantic_ai import TaskManager\n\n# Create your custom bus\nbus = RedisMessageBus(redis_url=\"redis://my-redis:6379\")\n\n# Use it with the task manager\nmanager = TaskManager(message_bus=bus)\n</code></pre> <p>Testing custom buses</p> <p>Start by verifying that your bus passes the same patterns as <code>InMemoryMessageBus</code>: register two agents, send a message from one to the other, call <code>ask</code>/<code>answer</code>, and confirm that <code>get_messages</code> returns the expected results.</p>"},{"location":"advanced/message-bus/#taskmanager","title":"TaskManager","text":"<p>The <code>TaskManager</code> coordinates tasks and message handling:</p> Python<pre><code>from subagents_pydantic_ai import TaskManager, InMemoryMessageBus\n\nbus = InMemoryMessageBus()\nmanager = TaskManager(message_bus=bus)\n</code></pre> <p>The task manager provides methods for the full task lifecycle:</p> Method Description <code>create_task(task_id, coro, handle)</code> Create and track a background asyncio task <code>get_handle(task_id)</code> Get the <code>TaskHandle</code> for a task <code>get_cancel_event(task_id)</code> Get the cancellation event for cooperative cancellation <code>soft_cancel(task_id)</code> Request cooperative cancellation <code>hard_cancel(task_id)</code> Force immediate cancellation <code>cleanup_task(task_id)</code> Remove task resources (handle is kept for status queries) <code>list_active_tasks()</code> Get IDs of all non-completed tasks"},{"location":"advanced/message-bus/#use-cases-for-custom-buses","title":"Use Cases for Custom Buses","text":""},{"location":"advanced/message-bus/#distributed-systems","title":"Distributed Systems","text":"<p>For multi-process or multi-machine deployments:</p> Python<pre><code># Process 1: Parent agent\nbus = RedisMessageBus(\"redis://localhost\")\nmanager = TaskManager(message_bus=bus)\n</code></pre>"},{"location":"advanced/message-bus/#persistent-queues","title":"Persistent Queues","text":"<p>For reliable delivery with persistence:</p> Python<pre><code>class RabbitMQBus:\n    \"\"\"RabbitMQ-based bus with message persistence.\"\"\"\n    ...\n</code></pre>"},{"location":"advanced/message-bus/#monitoring","title":"Monitoring","text":"<p>For observability and debugging, wrap an existing bus:</p> Python<pre><code>class MonitoredBus:\n    \"\"\"Wrapper that logs all messages.\"\"\"\n\n    def __init__(self, inner_bus: MessageBusProtocol):\n        self.inner = inner_bus\n\n    async def send(self, message: AgentMessage) -&gt; None:\n        logger.info(f\"Sending: {message.type} from {message.sender}\")\n        await self.inner.send(message)\n        metrics.increment(\"messages_sent\", tags={\"type\": message.type})\n</code></pre> <p>Alternatively, use the <code>add_handler</code> method on <code>InMemoryMessageBus</code> to add lightweight monitoring without wrapping:</p> Python<pre><code>bus = InMemoryMessageBus()\n\nasync def log_messages(message: AgentMessage) -&gt; None:\n    logger.info(f\"[{message.type}] {message.sender} \u2192 {message.receiver}\")\n\nbus.add_handler(log_messages)\n</code></pre>"},{"location":"advanced/message-bus/#best-practices","title":"Best Practices","text":""},{"location":"advanced/message-bus/#1-use-in-memory-for-simple-cases","title":"1. Use In-Memory for Simple Cases","text":"<p>Don't over-engineer. In-memory is fine for most applications:</p> Python<pre><code># Simple and effective\ntoolset = create_subagent_toolset(subagents=subagents)\n</code></pre>"},{"location":"advanced/message-bus/#2-consider-reliability","title":"2. Consider Reliability","text":"<p>For production distributed systems, use reliable message queues:</p> <ul> <li>Redis with persistence</li> <li>RabbitMQ</li> <li>Amazon SQS</li> </ul>"},{"location":"advanced/message-bus/#3-handle-failures","title":"3. Handle Failures","text":"<p>Implement retry logic and dead letter queues:</p> Python<pre><code>class ReliableBus:\n    async def send(self, message: AgentMessage) -&gt; None:\n        for attempt in range(3):\n            try:\n                await self._send(message)\n                return\n            except Exception:\n                if attempt == 2:\n                    await self._send_to_dlq(message)\n                    raise\n                await asyncio.sleep(2 ** attempt)\n</code></pre>"},{"location":"advanced/message-bus/#4-match-the-protocol-exactly","title":"4. Match the Protocol Exactly","text":"<p>When implementing a custom bus, make sure every method from <code>MessageBusProtocol</code> is present with matching signatures. The protocol is <code>@runtime_checkable</code>, so you can verify at startup:</p> Python<pre><code>assert isinstance(my_bus, MessageBusProtocol)\n</code></pre>"},{"location":"advanced/message-bus/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Working examples</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"advanced/questions/","title":"Parent-Child Questions","text":"<p>Subagents can ask the parent agent for clarification during task execution. This enables interactive workflows where subagents don't have to guess when information is ambiguous.</p>"},{"location":"advanced/questions/#enabling-questions","title":"Enabling Questions","text":"<p>Enable the <code>ask_parent</code> tool for a subagent:</p> Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    description=\"Analyzes data with clarifying questions\",\n    instructions=\"\"\"You analyze data thoroughly.\n\nWhen data is ambiguous or you need clarification:\n- Use the ask_parent tool to ask the parent\n- Wait for the answer before proceeding\n- Don't guess or assume\n\"\"\",\n    can_ask_questions=True,\n    max_questions=3,  # Limit questions per task\n)\n</code></pre>"},{"location":"advanced/questions/#how-it-works","title":"How It Works","text":"<ol> <li> <p>Subagent encounters ambiguity:    Text Only<pre><code>Subagent: \"The data mentions 'revenue' but doesn't specify\nthe time period. I need to ask for clarification.\"\n</code></pre></p> </li> <li> <p>Subagent asks parent:    Python<pre><code># Subagent calls:\nask_parent(\"Should I analyze Q1, Q2, or full year revenue?\")\n</code></pre></p> </li> <li> <p>Task enters WAITING_FOR_ANSWER state</p> </li> <li> <p>Parent checks task (if async) or sees question (if sync):    Python<pre><code># Parent calls:\ncheck_task(task_id=\"abc123\")\n# Returns: \"Task waiting for answer: Should I analyze Q1, Q2, or full year revenue?\"\n</code></pre></p> </li> <li> <p>Parent answers:    Python<pre><code># Parent calls:\nanswer_subagent(task_id=\"abc123\", answer=\"Analyze full year revenue\")\n</code></pre></p> </li> <li> <p>Subagent continues with the answer</p> </li> </ol>"},{"location":"advanced/questions/#question-limits","title":"Question Limits","text":"<p>Prevent infinite question loops with <code>max_questions</code>:</p> Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    ...\n    can_ask_questions=True,\n    max_questions=3,  # After 3 questions, must complete without asking more\n)\n</code></pre> <p>If the limit is reached, the subagent should proceed with best judgment or return partial results.</p>"},{"location":"advanced/questions/#sync-vs-async-questions","title":"Sync vs Async Questions","text":""},{"location":"advanced/questions/#sync-mode","title":"Sync Mode","text":"<p>In sync mode, questions block the parent immediately:</p> Python<pre><code># Parent calls:\ntask(description=\"Analyze the report\", subagent_type=\"analyst\", mode=\"sync\")\n\n# If subagent asks a question, the task pauses and parent sees:\n# \"Subagent question: What time period should I focus on?\"\n\n# Parent must answer to continue:\nanswer_subagent(task_id=\"...\", answer=\"Focus on Q4 2024\")\n\n# Task continues and eventually returns result\n</code></pre>"},{"location":"advanced/questions/#async-mode","title":"Async Mode","text":"<p>In async mode, questions put the task in WAITING_FOR_ANSWER state:</p> Python<pre><code># Parent calls:\ntask(description=\"Analyze the report\", subagent_type=\"analyst\", mode=\"async\")\n# Returns: \"Task started with ID: abc123\"\n\n# Parent does other work...\n\n# Later, parent checks:\ncheck_task(task_id=\"abc123\")\n# Returns: \"Task waiting for answer: What time period should I focus on?\"\n\n# Parent answers:\nanswer_subagent(task_id=\"abc123\", answer=\"Focus on Q4 2024\")\n\n# Task continues in background\ncheck_task(task_id=\"abc123\")\n# Eventually returns: \"Task complete: [analysis results]\"\n</code></pre>"},{"location":"advanced/questions/#writing-good-questions","title":"Writing Good Questions","text":"<p>Guide your subagents to ask effective questions:</p> Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    instructions=\"\"\"When asking questions:\n\n1. Be specific about what you need\n   \u274c \"What should I do?\"\n   \u2705 \"Should I include outliers in the statistical analysis?\"\n\n2. Provide context\n   \u274c \"Which one?\"\n   \u2705 \"The data has two revenue columns: 'revenue_gross' and 'revenue_net'. Which should I use for the margin calculation?\"\n\n3. Offer options when possible\n   \u274c \"What format?\"\n   \u2705 \"Should I format the output as: (a) JSON, (b) Markdown table, or (c) plain text?\"\n\"\"\",\n    can_ask_questions=True,\n)\n</code></pre>"},{"location":"advanced/questions/#example-interactive-analysis","title":"Example: Interactive Analysis","text":"Python<pre><code>from subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\nsubagents = [\n    SubAgentConfig(\n        name=\"data-analyst\",\n        description=\"Analyzes data with clarifying questions\",\n        instructions=\"\"\"You are a data analyst.\n\nWhen analyzing data:\n1. First understand what metrics are needed\n2. Ask for clarification if requirements are ambiguous\n3. Provide detailed analysis with visualizations\n\nAlways ask before making assumptions about:\n- Time periods\n- Metrics to include\n- Comparison baselines\n- Output format\n\"\"\",\n        can_ask_questions=True,\n        max_questions=5,\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n</code></pre>"},{"location":"advanced/questions/#the-answer_subagent-tool","title":"The <code>answer_subagent</code> Tool","text":"<p>The <code>answer_subagent</code> tool is how a parent agent responds to questions from subagents. It is part of the toolset created by <code>create_subagent_toolset()</code>.</p>"},{"location":"advanced/questions/#how-it-works_1","title":"How It Works","text":"<ol> <li>A subagent calls <code>ask_parent(question)</code> during task execution</li> <li>For async tasks, the task status changes to <code>WAITING_FOR_ANSWER</code> and <code>handle.pending_question</code> is set to the question text</li> <li>The parent discovers the question by calling <code>check_task(task_id)</code> (async) or sees it inline (sync)</li> <li>The parent calls <code>answer_subagent(task_id, answer)</code> to provide the response</li> <li>The tool creates an <code>ANSWER</code> message on the message bus and resets the task status to <code>RUNNING</code></li> <li>The subagent receives the answer and continues execution</li> </ol>"},{"location":"advanced/questions/#when-the-parent-should-use-it","title":"When the Parent Should Use It","text":"<p>The parent uses <code>answer_subagent</code> whenever <code>check_task</code> reports a <code>WAITING_FOR_ANSWER</code> status. In a typical workflow:</p> Python<pre><code># Parent checks on a background task\ncheck_task(task_id=\"abc123\")\n# Response: \"Task: abc123\n#            Subagent: data-analyst\n#            Status: waiting_for_answer\n#            Question: Should I use gross or net revenue for the margin calculation?\"\n\n# Parent provides the answer\nanswer_subagent(task_id=\"abc123\", answer=\"Use net revenue\")\n# Response: \"Answer sent to task 'abc123'\"\n</code></pre>"},{"location":"advanced/questions/#validation-and-error-handling","title":"Validation and Error Handling","text":"<p>The tool validates before sending:</p> <ul> <li>Task not found: Returns an error if the <code>task_id</code> does not exist</li> <li>Wrong status: Returns an error if the task is not in <code>WAITING_FOR_ANSWER</code> state (e.g., already completed or still running without a question)</li> <li>Subagent unavailable: Returns an error if the subagent's message bus channel is no longer registered</li> </ul> Python<pre><code># Attempting to answer a task that isn't waiting\nanswer_subagent(task_id=\"abc123\", answer=\"Use net revenue\")\n# Response: \"Error: Task 'abc123' is not waiting for an answer (status: running)\"\n</code></pre>"},{"location":"advanced/questions/#complete-async-qa-example","title":"Complete Async Q&amp;A Example","text":"Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"auditor\",\n        description=\"Audits financial data with clarifying questions\",\n        instructions=\"\"\"You audit financial records.\n\nBefore proceeding, clarify:\n- Which fiscal year to audit\n- Whether to include subsidiaries\n- Which accounting standard (GAAP or IFRS)\n\nUse ask_parent() for each clarification.\n\"\"\",\n        can_ask_questions=True,\n        max_questions=3,\n        preferred_mode=\"async\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You manage financial auditing tasks.\n\nWhen an auditor asks a question:\n1. Check task status with check_task()\n2. If WAITING_FOR_ANSWER, use answer_subagent() to respond\n3. Continue checking until the audit is complete\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # Turn 1: Start audit\n    result1 = await agent.run(\"Audit the company finances\", deps=deps)\n    print(result1.output)\n    # \"Started audit task. Task ID: audit-abc\"\n\n    # Turn 2: Check status, answer question\n    result2 = await agent.run(\n        \"Check the audit task and answer any questions\",\n        deps=deps,\n        message_history=result1.all_messages(),\n    )\n    print(result2.output)\n    # \"Auditor asks: Which fiscal year? I answered: FY 2025\"\n\n    # Turn 3: Continue checking, answer more questions or get results\n    result3 = await agent.run(\n        \"Check audit progress\",\n        deps=deps,\n        message_history=result2.all_messages(),\n    )\n    print(result3.output)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/questions/#best-practices","title":"Best Practices","text":""},{"location":"advanced/questions/#1-set-appropriate-limits","title":"1. Set Appropriate Limits","text":"<ul> <li>Simple tasks: <code>max_questions=1-2</code></li> <li>Complex analysis: <code>max_questions=3-5</code></li> <li>Exploratory work: <code>max_questions=5-10</code></li> </ul>"},{"location":"advanced/questions/#2-guide-question-behavior","title":"2. Guide Question Behavior","text":"<p>Include instructions about when to ask vs. when to proceed:</p> Python<pre><code>instructions=\"\"\"\nAsk questions when:\n- Requirements are ambiguous\n- Multiple valid interpretations exist\n- Significant assumptions would be needed\n\nDon't ask questions for:\n- Minor details you can reasonably infer\n- Standard conventions in the domain\n- Things explicitly stated in the task\n\"\"\"\n</code></pre>"},{"location":"advanced/questions/#3-handle-timeouts","title":"3. Handle Timeouts","text":"<p>For async tasks, consider what happens if questions aren't answered:</p> Python<pre><code>instructions=\"\"\"\nIf you've asked a question and been waiting a long time:\n- Proceed with the most reasonable assumption\n- Clearly document your assumption in the output\n- Note that results may need revision\n\"\"\"\n</code></pre>"},{"location":"advanced/questions/#4-coach-the-parent-on-answering","title":"4. Coach the Parent on Answering","text":"<p>Include guidance in the parent agent's system prompt so it knows how to handle questions:</p> Python<pre><code>system_prompt=\"\"\"\nWhen you see a subagent question via check_task():\n- Read the question carefully\n- Provide a clear, actionable answer using answer_subagent()\n- If you don't know, say so explicitly rather than guessing\n- Check back after answering to see if more questions arise\n\"\"\"\n</code></pre>"},{"location":"advanced/questions/#next-steps","title":"Next Steps","text":"<ul> <li>Cancellation - Managing task lifecycle</li> <li>Examples - Working examples</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for Subagents for Pydantic AI.</p>"},{"location":"api/#modules","title":"Modules","text":""},{"location":"api/#toolset","title":"Toolset","text":"<p>The main entry point for creating subagent delegation capabilities.</p> <ul> <li><code>create_subagent_toolset()</code> - Create a subagent toolset</li> <li><code>create_agent_factory_toolset()</code> - Create dynamic agent factory</li> <li><code>SubAgentToolset</code> - The toolset class</li> <li><code>get_subagent_system_prompt()</code> - Generate system prompt</li> </ul>"},{"location":"api/#types","title":"Types","text":"<p>Data structures used throughout the library.</p> <ul> <li><code>SubAgentConfig</code> - Subagent configuration</li> <li><code>CompiledSubAgent</code> - Pre-compiled subagent</li> <li><code>TaskHandle</code> - Background task handle</li> <li><code>TaskStatus</code> - Task status enum</li> <li><code>TaskPriority</code> - Task priority enum</li> <li><code>ExecutionMode</code> - Execution mode type</li> <li><code>TaskCharacteristics</code> - Auto-mode characteristics</li> <li><code>AgentMessage</code> - Inter-agent message</li> <li><code>MessageType</code> - Message type enum</li> <li><code>decide_execution_mode()</code> - Mode selection function</li> </ul>"},{"location":"api/#protocols","title":"Protocols","text":"<p>Interface definitions for extensibility.</p> <ul> <li><code>SubAgentDepsProtocol</code> - Dependencies protocol</li> <li><code>MessageBusProtocol</code> - Message bus protocol</li> </ul>"},{"location":"api/#message-bus","title":"Message Bus","text":"<p>Communication layer components.</p> <ul> <li><code>InMemoryMessageBus</code> - Default message bus</li> <li><code>TaskManager</code> - Task coordination</li> <li><code>create_message_bus()</code> - Factory function</li> </ul>"},{"location":"api/#registry","title":"Registry","text":"<p>Dynamic agent management.</p> <ul> <li><code>DynamicAgentRegistry</code> - Agent registry</li> </ul>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#creating-a-toolset","title":"Creating a Toolset","text":"Python<pre><code>from subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"You are a research assistant.\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n</code></pre>"},{"location":"api/#implementing-dependencies","title":"Implementing Dependencies","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n</code></pre>"},{"location":"api/#all-exports","title":"All Exports","text":"Python<pre><code>from subagents_pydantic_ai import (\n    # Toolsets\n    create_subagent_toolset,\n    SubAgentToolset,\n    create_agent_factory_toolset,\n    # Types\n    SubAgentConfig,\n    CompiledSubAgent,\n    TaskHandle,\n    TaskStatus,\n    TaskPriority,\n    TaskCharacteristics,\n    ExecutionMode,\n    AgentMessage,\n    MessageType,\n    ToolsetFactory,\n    # Functions\n    decide_execution_mode,\n    get_subagent_system_prompt,\n    get_task_instructions_prompt,\n    # Protocols\n    SubAgentDepsProtocol,\n    MessageBusProtocol,\n    # Message Bus\n    InMemoryMessageBus,\n    create_message_bus,\n    TaskManager,\n    # Registry\n    DynamicAgentRegistry,\n    # Prompts\n    SUBAGENT_SYSTEM_PROMPT,\n    DUAL_MODE_SYSTEM_PROMPT,\n    DEFAULT_GENERAL_PURPOSE_DESCRIPTION,\n    TASK_TOOL_DESCRIPTION,\n)\n</code></pre>"},{"location":"api/protocols/","title":"Protocols API","text":""},{"location":"api/protocols/#subagentdepsprotocol","title":"SubAgentDepsProtocol","text":""},{"location":"api/protocols/#subagents_pydantic_ai.SubAgentDepsProtocol","title":"<code>subagents_pydantic_ai.SubAgentDepsProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for dependencies that support subagent management.</p> <p>Any deps class that wants to use the subagent toolset must implement this protocol. The key requirement is a <code>subagents</code> dict for storing compiled agent instances and a <code>clone_for_subagent</code> method for creating isolated deps for nested subagents.</p> Example Python<pre><code>@dataclass\nclass MyDeps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"MyDeps\":\n        return MyDeps(\n            subagents={} if max_depth &lt;= 0 else self.subagents,\n        )\n</code></pre> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>@runtime_checkable\nclass SubAgentDepsProtocol(Protocol):\n    \"\"\"Protocol for dependencies that support subagent management.\n\n    Any deps class that wants to use the subagent toolset must implement\n    this protocol. The key requirement is a `subagents` dict for storing\n    compiled agent instances and a `clone_for_subagent` method for creating\n    isolated deps for nested subagents.\n\n    Example:\n        ```python\n        @dataclass\n        class MyDeps:\n            subagents: dict[str, Any] = field(default_factory=dict)\n\n            def clone_for_subagent(self, max_depth: int = 0) -&gt; \"MyDeps\":\n                return MyDeps(\n                    subagents={} if max_depth &lt;= 0 else self.subagents,\n                )\n        ```\n    \"\"\"\n\n    subagents: dict[str, Any]\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; SubAgentDepsProtocol:\n        \"\"\"Create a new deps instance for a subagent.\n\n        Subagents typically get:\n        - Shared resources (backend, files, etc.)\n        - Empty or limited subagents dict (based on max_depth)\n        - Fresh state for task-specific data\n\n        Args:\n            max_depth: Maximum nesting depth for the subagent.\n                If 0, the subagent cannot spawn further subagents.\n\n        Returns:\n            A new deps instance configured for the subagent.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.SubAgentDepsProtocol.clone_for_subagent","title":"<code>clone_for_subagent(max_depth=0)</code>","text":"<p>Create a new deps instance for a subagent.</p> <p>Subagents typically get: - Shared resources (backend, files, etc.) - Empty or limited subagents dict (based on max_depth) - Fresh state for task-specific data</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>int</code> <p>Maximum nesting depth for the subagent. If 0, the subagent cannot spawn further subagents.</p> <code>0</code> <p>Returns:</p> Type Description <code>SubAgentDepsProtocol</code> <p>A new deps instance configured for the subagent.</p> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>def clone_for_subagent(self, max_depth: int = 0) -&gt; SubAgentDepsProtocol:\n    \"\"\"Create a new deps instance for a subagent.\n\n    Subagents typically get:\n    - Shared resources (backend, files, etc.)\n    - Empty or limited subagents dict (based on max_depth)\n    - Fresh state for task-specific data\n\n    Args:\n        max_depth: Maximum nesting depth for the subagent.\n            If 0, the subagent cannot spawn further subagents.\n\n    Returns:\n        A new deps instance configured for the subagent.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#messagebusprotocol","title":"MessageBusProtocol","text":""},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol","title":"<code>subagents_pydantic_ai.MessageBusProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for message bus implementations.</p> <p>The message bus enables communication between agents, supporting both fire-and-forget messages and request-response patterns.</p> <p>Implementations can use different backends: - In-memory (default): Uses asyncio queues - Redis: For distributed multi-process setups - Custom: Any backend implementing this protocol</p> Example Python<pre><code>bus = InMemoryMessageBus()\n\n# Register an agent\nqueue = bus.register_agent(\"worker-1\")\n\n# Send a message\nawait bus.send(AgentMessage(\n    type=MessageType.TASK_UPDATE,\n    sender=\"parent\",\n    receiver=\"worker-1\",\n    payload={\"status\": \"starting\"},\n))\n\n# Request-response pattern\nresponse = await bus.ask(\n    sender=\"parent\",\n    receiver=\"worker-1\",\n    question=\"What is your status?\",\n    task_id=\"task-123\",\n    timeout=30.0,\n)\n</code></pre> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>@runtime_checkable\nclass MessageBusProtocol(Protocol):\n    \"\"\"Protocol for message bus implementations.\n\n    The message bus enables communication between agents, supporting\n    both fire-and-forget messages and request-response patterns.\n\n    Implementations can use different backends:\n    - In-memory (default): Uses asyncio queues\n    - Redis: For distributed multi-process setups\n    - Custom: Any backend implementing this protocol\n\n    Example:\n        ```python\n        bus = InMemoryMessageBus()\n\n        # Register an agent\n        queue = bus.register_agent(\"worker-1\")\n\n        # Send a message\n        await bus.send(AgentMessage(\n            type=MessageType.TASK_UPDATE,\n            sender=\"parent\",\n            receiver=\"worker-1\",\n            payload={\"status\": \"starting\"},\n        ))\n\n        # Request-response pattern\n        response = await bus.ask(\n            sender=\"parent\",\n            receiver=\"worker-1\",\n            question=\"What is your status?\",\n            task_id=\"task-123\",\n            timeout=30.0,\n        )\n        ```\n    \"\"\"\n\n    async def send(self, message: AgentMessage) -&gt; None:\n        \"\"\"Send a message to a specific agent.\n\n        Args:\n            message: The message to send. Must have a valid receiver.\n\n        Raises:\n            KeyError: If the receiver is not registered.\n        \"\"\"\n        ...\n\n    async def ask(\n        self,\n        sender: str,\n        receiver: str,\n        question: Any,\n        task_id: str,\n        timeout: float = 30.0,\n    ) -&gt; AgentMessage:\n        \"\"\"Send a question and wait for a response.\n\n        This implements a request-response pattern where the sender\n        blocks until the receiver answers or the timeout expires.\n\n        Args:\n            sender: ID of the asking agent.\n            receiver: ID of the agent to ask.\n            question: The question payload.\n            task_id: Task ID for correlation.\n            timeout: Maximum time to wait for response in seconds.\n\n        Returns:\n            The response message from the receiver.\n\n        Raises:\n            asyncio.TimeoutError: If no response within timeout.\n            KeyError: If the receiver is not registered.\n        \"\"\"\n        ...\n\n    async def answer(self, original: AgentMessage, answer: Any) -&gt; None:\n        \"\"\"Answer a previously received question.\n\n        Args:\n            original: The original question message.\n            answer: The answer payload.\n        \"\"\"\n        ...\n\n    def register_agent(self, agent_id: str) -&gt; asyncio.Queue[AgentMessage]:\n        \"\"\"Register an agent to receive messages.\n\n        Args:\n            agent_id: Unique identifier for the agent.\n\n        Returns:\n            A queue where messages for this agent will be delivered.\n\n        Raises:\n            ValueError: If agent_id is already registered.\n        \"\"\"\n        ...\n\n    def unregister_agent(self, agent_id: str) -&gt; None:\n        \"\"\"Unregister an agent from the message bus.\n\n        After unregistration, messages sent to this agent will raise errors.\n\n        Args:\n            agent_id: The agent to unregister.\n        \"\"\"\n        ...\n\n    async def get_messages(\n        self,\n        agent_id: str,\n        timeout: float = 0.0,\n    ) -&gt; list[AgentMessage]:\n        \"\"\"Get pending messages for an agent.\n\n        Non-blocking retrieval of all pending messages in the agent's queue.\n        Optionally waits up to `timeout` seconds for at least one message.\n\n        Args:\n            agent_id: The agent to get messages for.\n            timeout: Maximum time to wait for a message (0 = no wait).\n\n        Returns:\n            List of pending messages (may be empty).\n\n        Raises:\n            KeyError: If the agent is not registered.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.send","title":"<code>send(message)</code>  <code>async</code>","text":"<p>Send a message to a specific agent.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AgentMessage</code> <p>The message to send. Must have a valid receiver.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the receiver is not registered.</p> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>async def send(self, message: AgentMessage) -&gt; None:\n    \"\"\"Send a message to a specific agent.\n\n    Args:\n        message: The message to send. Must have a valid receiver.\n\n    Raises:\n        KeyError: If the receiver is not registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.ask","title":"<code>ask(sender, receiver, question, task_id, timeout=30.0)</code>  <code>async</code>","text":"<p>Send a question and wait for a response.</p> <p>This implements a request-response pattern where the sender blocks until the receiver answers or the timeout expires.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>str</code> <p>ID of the asking agent.</p> required <code>receiver</code> <code>str</code> <p>ID of the agent to ask.</p> required <code>question</code> <code>Any</code> <p>The question payload.</p> required <code>task_id</code> <code>str</code> <p>Task ID for correlation.</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait for response in seconds.</p> <code>30.0</code> <p>Returns:</p> Type Description <code>AgentMessage</code> <p>The response message from the receiver.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If no response within timeout.</p> <code>KeyError</code> <p>If the receiver is not registered.</p> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>async def ask(\n    self,\n    sender: str,\n    receiver: str,\n    question: Any,\n    task_id: str,\n    timeout: float = 30.0,\n) -&gt; AgentMessage:\n    \"\"\"Send a question and wait for a response.\n\n    This implements a request-response pattern where the sender\n    blocks until the receiver answers or the timeout expires.\n\n    Args:\n        sender: ID of the asking agent.\n        receiver: ID of the agent to ask.\n        question: The question payload.\n        task_id: Task ID for correlation.\n        timeout: Maximum time to wait for response in seconds.\n\n    Returns:\n        The response message from the receiver.\n\n    Raises:\n        asyncio.TimeoutError: If no response within timeout.\n        KeyError: If the receiver is not registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.answer","title":"<code>answer(original, answer)</code>  <code>async</code>","text":"<p>Answer a previously received question.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>AgentMessage</code> <p>The original question message.</p> required <code>answer</code> <code>Any</code> <p>The answer payload.</p> required Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>async def answer(self, original: AgentMessage, answer: Any) -&gt; None:\n    \"\"\"Answer a previously received question.\n\n    Args:\n        original: The original question message.\n        answer: The answer payload.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.register_agent","title":"<code>register_agent(agent_id)</code>","text":"<p>Register an agent to receive messages.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Unique identifier for the agent.</p> required <p>Returns:</p> Type Description <code>Queue[AgentMessage]</code> <p>A queue where messages for this agent will be delivered.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If agent_id is already registered.</p> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>def register_agent(self, agent_id: str) -&gt; asyncio.Queue[AgentMessage]:\n    \"\"\"Register an agent to receive messages.\n\n    Args:\n        agent_id: Unique identifier for the agent.\n\n    Returns:\n        A queue where messages for this agent will be delivered.\n\n    Raises:\n        ValueError: If agent_id is already registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.unregister_agent","title":"<code>unregister_agent(agent_id)</code>","text":"<p>Unregister an agent from the message bus.</p> <p>After unregistration, messages sent to this agent will raise errors.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The agent to unregister.</p> required Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>def unregister_agent(self, agent_id: str) -&gt; None:\n    \"\"\"Unregister an agent from the message bus.\n\n    After unregistration, messages sent to this agent will raise errors.\n\n    Args:\n        agent_id: The agent to unregister.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.MessageBusProtocol.get_messages","title":"<code>get_messages(agent_id, timeout=0.0)</code>  <code>async</code>","text":"<p>Get pending messages for an agent.</p> <p>Non-blocking retrieval of all pending messages in the agent's queue. Optionally waits up to <code>timeout</code> seconds for at least one message.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The agent to get messages for.</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait for a message (0 = no wait).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[AgentMessage]</code> <p>List of pending messages (may be empty).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the agent is not registered.</p> Source code in <code>src/subagents_pydantic_ai/protocols.py</code> Python<pre><code>async def get_messages(\n    self,\n    agent_id: str,\n    timeout: float = 0.0,\n) -&gt; list[AgentMessage]:\n    \"\"\"Get pending messages for an agent.\n\n    Non-blocking retrieval of all pending messages in the agent's queue.\n    Optionally waits up to `timeout` seconds for at least one message.\n\n    Args:\n        agent_id: The agent to get messages for.\n        timeout: Maximum time to wait for a message (0 = no wait).\n\n    Returns:\n        List of pending messages (may be empty).\n\n    Raises:\n        KeyError: If the agent is not registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#inmemorymessagebus","title":"InMemoryMessageBus","text":""},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus","title":"<code>subagents_pydantic_ai.InMemoryMessageBus</code>  <code>dataclass</code>","text":"<p>In-memory message bus using asyncio queues.</p> <p>This is the default message bus implementation, suitable for single-process applications. For distributed systems, consider implementing a Redis-based bus using the MessageBusProtocol.</p> Example Python<pre><code>bus = InMemoryMessageBus()\n\n# Register agents\nparent_queue = bus.register_agent(\"parent\")\nworker_queue = bus.register_agent(\"worker-1\")\n\n# Send a message\nawait bus.send(AgentMessage(\n    type=MessageType.TASK_ASSIGNED,\n    sender=\"parent\",\n    receiver=\"worker-1\",\n    payload={\"task\": \"analyze data\"},\n    task_id=\"task-123\",\n))\n\n# Worker receives message\nmsg = await worker_queue.get()\n</code></pre> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>@dataclass\nclass InMemoryMessageBus:\n    \"\"\"In-memory message bus using asyncio queues.\n\n    This is the default message bus implementation, suitable for\n    single-process applications. For distributed systems, consider\n    implementing a Redis-based bus using the MessageBusProtocol.\n\n    Example:\n        ```python\n        bus = InMemoryMessageBus()\n\n        # Register agents\n        parent_queue = bus.register_agent(\"parent\")\n        worker_queue = bus.register_agent(\"worker-1\")\n\n        # Send a message\n        await bus.send(AgentMessage(\n            type=MessageType.TASK_ASSIGNED,\n            sender=\"parent\",\n            receiver=\"worker-1\",\n            payload={\"task\": \"analyze data\"},\n            task_id=\"task-123\",\n        ))\n\n        # Worker receives message\n        msg = await worker_queue.get()\n        ```\n    \"\"\"\n\n    _queues: dict[str, asyncio.Queue[AgentMessage]] = field(default_factory=dict)\n    _pending_questions: dict[str, asyncio.Future[AgentMessage]] = field(default_factory=dict)\n    _handlers: list[Callable[[AgentMessage], Awaitable[None]]] = field(default_factory=list)\n\n    async def send(self, message: AgentMessage) -&gt; None:\n        \"\"\"Send a message to a specific agent.\n\n        Args:\n            message: The message to send.\n\n        Raises:\n            KeyError: If the receiver is not registered.\n        \"\"\"\n        if message.receiver not in self._queues:\n            raise KeyError(f\"Agent '{message.receiver}' is not registered\")\n\n        await self._queues[message.receiver].put(message)\n\n        # Notify handlers\n        for handler in self._handlers:\n            try:\n                await handler(message)\n            except Exception:  # pragma: no cover\n                pass  # Don't let handler errors break message delivery\n\n    async def ask(\n        self,\n        sender: str,\n        receiver: str,\n        question: Any,\n        task_id: str,\n        timeout: float = 30.0,\n    ) -&gt; AgentMessage:\n        \"\"\"Send a question and wait for a response.\n\n        Args:\n            sender: ID of the asking agent.\n            receiver: ID of the agent to ask.\n            question: The question payload.\n            task_id: Task ID for correlation.\n            timeout: Maximum time to wait in seconds.\n\n        Returns:\n            The response message.\n\n        Raises:\n            asyncio.TimeoutError: If no response within timeout.\n            KeyError: If the receiver is not registered.\n        \"\"\"\n        if receiver not in self._queues:\n            raise KeyError(f\"Agent '{receiver}' is not registered\")\n\n        correlation_id = str(uuid.uuid4())\n\n        # Create future for the response\n        loop = asyncio.get_event_loop()\n        response_future: asyncio.Future[AgentMessage] = loop.create_future()\n        self._pending_questions[correlation_id] = response_future\n\n        try:\n            # Send the question\n            message = AgentMessage(\n                type=MessageType.QUESTION,\n                sender=sender,\n                receiver=receiver,\n                payload=question,\n                task_id=task_id,\n                correlation_id=correlation_id,\n            )\n            await self.send(message)\n\n            # Wait for response\n            return await asyncio.wait_for(response_future, timeout=timeout)\n        finally:\n            # Clean up\n            self._pending_questions.pop(correlation_id, None)\n\n    async def answer(self, original: AgentMessage, answer: Any) -&gt; None:\n        \"\"\"Answer a previously received question.\n\n        Args:\n            original: The original question message.\n            answer: The answer payload.\n\n        Raises:\n            KeyError: If the original sender is not registered or\n                     if there's no pending question with the correlation_id.\n        \"\"\"\n        if original.sender not in self._queues:\n            raise KeyError(f\"Agent '{original.sender}' is not registered\")\n\n        response = AgentMessage(\n            type=MessageType.ANSWER,\n            sender=original.receiver,  # We are the original receiver\n            receiver=original.sender,  # Send back to original sender\n            payload=answer,\n            task_id=original.task_id,\n            correlation_id=original.correlation_id,\n        )\n\n        # If there's a pending future for this correlation_id, resolve it\n        if original.correlation_id and original.correlation_id in self._pending_questions:\n            future = self._pending_questions[original.correlation_id]\n            if not future.done():\n                future.set_result(response)\n        else:\n            # Otherwise, put in queue\n            await self.send(response)\n\n    def register_agent(self, agent_id: str) -&gt; asyncio.Queue[AgentMessage]:\n        \"\"\"Register an agent to receive messages.\n\n        Args:\n            agent_id: Unique identifier for the agent.\n\n        Returns:\n            A queue where messages for this agent will be delivered.\n\n        Raises:\n            ValueError: If agent_id is already registered.\n        \"\"\"\n        if agent_id in self._queues:\n            raise ValueError(f\"Agent '{agent_id}' is already registered\")\n\n        queue: asyncio.Queue[AgentMessage] = asyncio.Queue()\n        self._queues[agent_id] = queue\n        return queue\n\n    def unregister_agent(self, agent_id: str) -&gt; None:\n        \"\"\"Unregister an agent from the message bus.\n\n        Args:\n            agent_id: The agent to unregister.\n        \"\"\"\n        self._queues.pop(agent_id, None)\n\n    def add_handler(self, handler: Callable[[AgentMessage], Awaitable[None]]) -&gt; None:\n        \"\"\"Add a message handler for debugging/logging.\n\n        Handlers are called for every message sent through the bus.\n\n        Args:\n            handler: Async function that receives messages.\n        \"\"\"\n        self._handlers.append(handler)\n\n    def remove_handler(self, handler: Callable[[AgentMessage], Awaitable[None]]) -&gt; None:\n        \"\"\"Remove a previously added handler.\n\n        Args:\n            handler: The handler to remove.\n        \"\"\"\n        if handler in self._handlers:\n            self._handlers.remove(handler)\n\n    def is_registered(self, agent_id: str) -&gt; bool:\n        \"\"\"Check if an agent is registered.\n\n        Args:\n            agent_id: The agent ID to check.\n\n        Returns:\n            True if the agent is registered, False otherwise.\n        \"\"\"\n        return agent_id in self._queues\n\n    def registered_agents(self) -&gt; list[str]:\n        \"\"\"Get list of registered agent IDs.\n\n        Returns:\n            List of registered agent IDs.\n        \"\"\"\n        return list(self._queues.keys())\n\n    async def get_messages(\n        self,\n        agent_id: str,\n        timeout: float = 0.0,\n    ) -&gt; list[AgentMessage]:\n        \"\"\"Get pending messages for an agent.\n\n        Non-blocking retrieval of all pending messages in the agent's queue.\n        Optionally waits up to `timeout` seconds for at least one message.\n\n        Args:\n            agent_id: The agent to get messages for.\n            timeout: Maximum time to wait for a message (0 = no wait).\n\n        Returns:\n            List of pending messages (may be empty).\n\n        Raises:\n            KeyError: If the agent is not registered.\n        \"\"\"\n        if agent_id not in self._queues:\n            raise KeyError(f\"Agent '{agent_id}' is not registered\")\n\n        queue = self._queues[agent_id]\n        messages: list[AgentMessage] = []\n\n        # If timeout &gt; 0 and queue is empty, wait for first message\n        if timeout &gt; 0 and queue.empty():\n            try:\n                msg = await asyncio.wait_for(queue.get(), timeout=timeout)\n                messages.append(msg)\n            except asyncio.TimeoutError:\n                return messages\n\n        # Drain all available messages\n        while not queue.empty():\n            try:\n                msg = queue.get_nowait()\n                messages.append(msg)\n            except asyncio.QueueEmpty:  # pragma: no cover\n                break  # Race condition - queue was emptied between empty() check and get_nowait()\n\n        return messages\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.send","title":"<code>send(message)</code>  <code>async</code>","text":"<p>Send a message to a specific agent.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AgentMessage</code> <p>The message to send.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the receiver is not registered.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def send(self, message: AgentMessage) -&gt; None:\n    \"\"\"Send a message to a specific agent.\n\n    Args:\n        message: The message to send.\n\n    Raises:\n        KeyError: If the receiver is not registered.\n    \"\"\"\n    if message.receiver not in self._queues:\n        raise KeyError(f\"Agent '{message.receiver}' is not registered\")\n\n    await self._queues[message.receiver].put(message)\n\n    # Notify handlers\n    for handler in self._handlers:\n        try:\n            await handler(message)\n        except Exception:  # pragma: no cover\n            pass  # Don't let handler errors break message delivery\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.ask","title":"<code>ask(sender, receiver, question, task_id, timeout=30.0)</code>  <code>async</code>","text":"<p>Send a question and wait for a response.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>str</code> <p>ID of the asking agent.</p> required <code>receiver</code> <code>str</code> <p>ID of the agent to ask.</p> required <code>question</code> <code>Any</code> <p>The question payload.</p> required <code>task_id</code> <code>str</code> <p>Task ID for correlation.</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds.</p> <code>30.0</code> <p>Returns:</p> Type Description <code>AgentMessage</code> <p>The response message.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If no response within timeout.</p> <code>KeyError</code> <p>If the receiver is not registered.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def ask(\n    self,\n    sender: str,\n    receiver: str,\n    question: Any,\n    task_id: str,\n    timeout: float = 30.0,\n) -&gt; AgentMessage:\n    \"\"\"Send a question and wait for a response.\n\n    Args:\n        sender: ID of the asking agent.\n        receiver: ID of the agent to ask.\n        question: The question payload.\n        task_id: Task ID for correlation.\n        timeout: Maximum time to wait in seconds.\n\n    Returns:\n        The response message.\n\n    Raises:\n        asyncio.TimeoutError: If no response within timeout.\n        KeyError: If the receiver is not registered.\n    \"\"\"\n    if receiver not in self._queues:\n        raise KeyError(f\"Agent '{receiver}' is not registered\")\n\n    correlation_id = str(uuid.uuid4())\n\n    # Create future for the response\n    loop = asyncio.get_event_loop()\n    response_future: asyncio.Future[AgentMessage] = loop.create_future()\n    self._pending_questions[correlation_id] = response_future\n\n    try:\n        # Send the question\n        message = AgentMessage(\n            type=MessageType.QUESTION,\n            sender=sender,\n            receiver=receiver,\n            payload=question,\n            task_id=task_id,\n            correlation_id=correlation_id,\n        )\n        await self.send(message)\n\n        # Wait for response\n        return await asyncio.wait_for(response_future, timeout=timeout)\n    finally:\n        # Clean up\n        self._pending_questions.pop(correlation_id, None)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.answer","title":"<code>answer(original, answer)</code>  <code>async</code>","text":"<p>Answer a previously received question.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>AgentMessage</code> <p>The original question message.</p> required <code>answer</code> <code>Any</code> <p>The answer payload.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the original sender is not registered or      if there's no pending question with the correlation_id.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def answer(self, original: AgentMessage, answer: Any) -&gt; None:\n    \"\"\"Answer a previously received question.\n\n    Args:\n        original: The original question message.\n        answer: The answer payload.\n\n    Raises:\n        KeyError: If the original sender is not registered or\n                 if there's no pending question with the correlation_id.\n    \"\"\"\n    if original.sender not in self._queues:\n        raise KeyError(f\"Agent '{original.sender}' is not registered\")\n\n    response = AgentMessage(\n        type=MessageType.ANSWER,\n        sender=original.receiver,  # We are the original receiver\n        receiver=original.sender,  # Send back to original sender\n        payload=answer,\n        task_id=original.task_id,\n        correlation_id=original.correlation_id,\n    )\n\n    # If there's a pending future for this correlation_id, resolve it\n    if original.correlation_id and original.correlation_id in self._pending_questions:\n        future = self._pending_questions[original.correlation_id]\n        if not future.done():\n            future.set_result(response)\n    else:\n        # Otherwise, put in queue\n        await self.send(response)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.register_agent","title":"<code>register_agent(agent_id)</code>","text":"<p>Register an agent to receive messages.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Unique identifier for the agent.</p> required <p>Returns:</p> Type Description <code>Queue[AgentMessage]</code> <p>A queue where messages for this agent will be delivered.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If agent_id is already registered.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def register_agent(self, agent_id: str) -&gt; asyncio.Queue[AgentMessage]:\n    \"\"\"Register an agent to receive messages.\n\n    Args:\n        agent_id: Unique identifier for the agent.\n\n    Returns:\n        A queue where messages for this agent will be delivered.\n\n    Raises:\n        ValueError: If agent_id is already registered.\n    \"\"\"\n    if agent_id in self._queues:\n        raise ValueError(f\"Agent '{agent_id}' is already registered\")\n\n    queue: asyncio.Queue[AgentMessage] = asyncio.Queue()\n    self._queues[agent_id] = queue\n    return queue\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.unregister_agent","title":"<code>unregister_agent(agent_id)</code>","text":"<p>Unregister an agent from the message bus.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The agent to unregister.</p> required Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def unregister_agent(self, agent_id: str) -&gt; None:\n    \"\"\"Unregister an agent from the message bus.\n\n    Args:\n        agent_id: The agent to unregister.\n    \"\"\"\n    self._queues.pop(agent_id, None)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.add_handler","title":"<code>add_handler(handler)</code>","text":"<p>Add a message handler for debugging/logging.</p> <p>Handlers are called for every message sent through the bus.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[AgentMessage], Awaitable[None]]</code> <p>Async function that receives messages.</p> required Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def add_handler(self, handler: Callable[[AgentMessage], Awaitable[None]]) -&gt; None:\n    \"\"\"Add a message handler for debugging/logging.\n\n    Handlers are called for every message sent through the bus.\n\n    Args:\n        handler: Async function that receives messages.\n    \"\"\"\n    self._handlers.append(handler)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.remove_handler","title":"<code>remove_handler(handler)</code>","text":"<p>Remove a previously added handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[AgentMessage], Awaitable[None]]</code> <p>The handler to remove.</p> required Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def remove_handler(self, handler: Callable[[AgentMessage], Awaitable[None]]) -&gt; None:\n    \"\"\"Remove a previously added handler.\n\n    Args:\n        handler: The handler to remove.\n    \"\"\"\n    if handler in self._handlers:\n        self._handlers.remove(handler)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.is_registered","title":"<code>is_registered(agent_id)</code>","text":"<p>Check if an agent is registered.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The agent ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the agent is registered, False otherwise.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def is_registered(self, agent_id: str) -&gt; bool:\n    \"\"\"Check if an agent is registered.\n\n    Args:\n        agent_id: The agent ID to check.\n\n    Returns:\n        True if the agent is registered, False otherwise.\n    \"\"\"\n    return agent_id in self._queues\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.registered_agents","title":"<code>registered_agents()</code>","text":"<p>Get list of registered agent IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of registered agent IDs.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def registered_agents(self) -&gt; list[str]:\n    \"\"\"Get list of registered agent IDs.\n\n    Returns:\n        List of registered agent IDs.\n    \"\"\"\n    return list(self._queues.keys())\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.InMemoryMessageBus.get_messages","title":"<code>get_messages(agent_id, timeout=0.0)</code>  <code>async</code>","text":"<p>Get pending messages for an agent.</p> <p>Non-blocking retrieval of all pending messages in the agent's queue. Optionally waits up to <code>timeout</code> seconds for at least one message.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The agent to get messages for.</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait for a message (0 = no wait).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[AgentMessage]</code> <p>List of pending messages (may be empty).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the agent is not registered.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def get_messages(\n    self,\n    agent_id: str,\n    timeout: float = 0.0,\n) -&gt; list[AgentMessage]:\n    \"\"\"Get pending messages for an agent.\n\n    Non-blocking retrieval of all pending messages in the agent's queue.\n    Optionally waits up to `timeout` seconds for at least one message.\n\n    Args:\n        agent_id: The agent to get messages for.\n        timeout: Maximum time to wait for a message (0 = no wait).\n\n    Returns:\n        List of pending messages (may be empty).\n\n    Raises:\n        KeyError: If the agent is not registered.\n    \"\"\"\n    if agent_id not in self._queues:\n        raise KeyError(f\"Agent '{agent_id}' is not registered\")\n\n    queue = self._queues[agent_id]\n    messages: list[AgentMessage] = []\n\n    # If timeout &gt; 0 and queue is empty, wait for first message\n    if timeout &gt; 0 and queue.empty():\n        try:\n            msg = await asyncio.wait_for(queue.get(), timeout=timeout)\n            messages.append(msg)\n        except asyncio.TimeoutError:\n            return messages\n\n    # Drain all available messages\n    while not queue.empty():\n        try:\n            msg = queue.get_nowait()\n            messages.append(msg)\n        except asyncio.QueueEmpty:  # pragma: no cover\n            break  # Race condition - queue was emptied between empty() check and get_nowait()\n\n    return messages\n</code></pre>"},{"location":"api/protocols/#taskmanager","title":"TaskManager","text":""},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager","title":"<code>subagents_pydantic_ai.TaskManager</code>  <code>dataclass</code>","text":"<p>Manages background tasks and their lifecycle.</p> <p>Tracks running tasks, handles cancellation, and provides status querying capabilities.</p> <p>Attributes:</p> Name Type Description <code>tasks</code> <code>dict[str, Task[Any]]</code> <p>Dictionary of task_id -&gt; asyncio.Task</p> <code>handles</code> <code>dict[str, Any]</code> <p>Dictionary of task_id -&gt; TaskHandle</p> <code>message_bus</code> <code>InMemoryMessageBus</code> <p>Message bus for communication</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>@dataclass\nclass TaskManager:\n    \"\"\"Manages background tasks and their lifecycle.\n\n    Tracks running tasks, handles cancellation, and provides\n    status querying capabilities.\n\n    Attributes:\n        tasks: Dictionary of task_id -&gt; asyncio.Task\n        handles: Dictionary of task_id -&gt; TaskHandle\n        message_bus: Message bus for communication\n    \"\"\"\n\n    tasks: dict[str, asyncio.Task[Any]] = field(default_factory=dict)\n    handles: dict[str, Any] = field(default_factory=dict)  # TaskHandle\n    message_bus: InMemoryMessageBus = field(default_factory=InMemoryMessageBus)\n    _cancel_events: dict[str, asyncio.Event] = field(default_factory=dict)\n\n    def create_task(\n        self,\n        task_id: str,\n        coro: Any,  # Coroutine\n        handle: Any,  # TaskHandle\n    ) -&gt; asyncio.Task[Any]:\n        \"\"\"Create and track a new background task.\n\n        Args:\n            task_id: Unique identifier for the task.\n            coro: The coroutine to run.\n            handle: TaskHandle for status tracking.\n\n        Returns:\n            The created asyncio.Task.\n        \"\"\"\n        task = asyncio.create_task(coro)\n        self.tasks[task_id] = task\n        self.handles[task_id] = handle\n        self._cancel_events[task_id] = asyncio.Event()\n\n        # Update handle when task starts\n        handle.status = \"running\"\n        handle.started_at = datetime.now()\n\n        return task\n\n    def get_handle(self, task_id: str) -&gt; Any | None:\n        \"\"\"Get the handle for a task.\n\n        Args:\n            task_id: The task ID.\n\n        Returns:\n            The TaskHandle if found, None otherwise.\n        \"\"\"\n        return self.handles.get(task_id)\n\n    def get_cancel_event(self, task_id: str) -&gt; asyncio.Event | None:\n        \"\"\"Get the cancellation event for a task.\n\n        Args:\n            task_id: The task ID.\n\n        Returns:\n            The cancellation event if found, None otherwise.\n        \"\"\"\n        return self._cancel_events.get(task_id)\n\n    async def soft_cancel(self, task_id: str) -&gt; bool:\n        \"\"\"Request cooperative cancellation of a task.\n\n        Sets a cancellation event that the task can check periodically.\n        The task is expected to clean up and exit gracefully.\n\n        Args:\n            task_id: The task to cancel.\n\n        Returns:\n            True if cancellation was requested, False if task not found.\n        \"\"\"\n        if task_id not in self._cancel_events:\n            return False\n\n        self._cancel_events[task_id].set()\n\n        # Send cancel request message\n        if task_id in self.handles:\n            handle = self.handles[task_id]\n            try:\n                await self.message_bus.send(\n                    AgentMessage(\n                        type=MessageType.CANCEL_REQUEST,\n                        sender=\"task_manager\",\n                        receiver=handle.subagent_name,\n                        payload={\"reason\": \"soft_cancel\"},\n                        task_id=task_id,\n                    )\n                )\n            except KeyError:\n                pass  # Agent not registered, that's OK\n\n        return True\n\n    async def hard_cancel(self, task_id: str) -&gt; bool:\n        \"\"\"Immediately cancel a task.\n\n        Calls cancel() on the asyncio.Task, causing CancelledError\n        to be raised in the task.\n\n        Args:\n            task_id: The task to cancel.\n\n        Returns:\n            True if task was cancelled, False if task not found.\n        \"\"\"\n        if task_id not in self.tasks:\n            return False\n\n        task = self.tasks[task_id]\n        if not task.done():\n            task.cancel()\n\n        # Update handle\n        if task_id in self.handles:\n            handle = self.handles[task_id]\n            handle.status = \"cancelled\"\n            handle.completed_at = datetime.now()\n\n        return True\n\n    def cleanup_task(self, task_id: str) -&gt; None:\n        \"\"\"Clean up resources for a completed task.\n\n        Args:\n            task_id: The task to clean up.\n        \"\"\"\n        self.tasks.pop(task_id, None)\n        self._cancel_events.pop(task_id, None)\n        # Keep handle for status queries\n\n    def list_active_tasks(self) -&gt; list[str]:\n        \"\"\"Get list of active (non-completed) task IDs.\n\n        Returns:\n            List of task IDs for tasks that haven't completed.\n        \"\"\"\n        return [task_id for task_id, task in self.tasks.items() if not task.done()]\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.create_task","title":"<code>create_task(task_id, coro, handle)</code>","text":"<p>Create and track a new background task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Unique identifier for the task.</p> required <code>coro</code> <code>Any</code> <p>The coroutine to run.</p> required <code>handle</code> <code>Any</code> <p>TaskHandle for status tracking.</p> required <p>Returns:</p> Type Description <code>Task[Any]</code> <p>The created asyncio.Task.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def create_task(\n    self,\n    task_id: str,\n    coro: Any,  # Coroutine\n    handle: Any,  # TaskHandle\n) -&gt; asyncio.Task[Any]:\n    \"\"\"Create and track a new background task.\n\n    Args:\n        task_id: Unique identifier for the task.\n        coro: The coroutine to run.\n        handle: TaskHandle for status tracking.\n\n    Returns:\n        The created asyncio.Task.\n    \"\"\"\n    task = asyncio.create_task(coro)\n    self.tasks[task_id] = task\n    self.handles[task_id] = handle\n    self._cancel_events[task_id] = asyncio.Event()\n\n    # Update handle when task starts\n    handle.status = \"running\"\n    handle.started_at = datetime.now()\n\n    return task\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.get_handle","title":"<code>get_handle(task_id)</code>","text":"<p>Get the handle for a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task ID.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The TaskHandle if found, None otherwise.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def get_handle(self, task_id: str) -&gt; Any | None:\n    \"\"\"Get the handle for a task.\n\n    Args:\n        task_id: The task ID.\n\n    Returns:\n        The TaskHandle if found, None otherwise.\n    \"\"\"\n    return self.handles.get(task_id)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.get_cancel_event","title":"<code>get_cancel_event(task_id)</code>","text":"<p>Get the cancellation event for a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task ID.</p> required <p>Returns:</p> Type Description <code>Event | None</code> <p>The cancellation event if found, None otherwise.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def get_cancel_event(self, task_id: str) -&gt; asyncio.Event | None:\n    \"\"\"Get the cancellation event for a task.\n\n    Args:\n        task_id: The task ID.\n\n    Returns:\n        The cancellation event if found, None otherwise.\n    \"\"\"\n    return self._cancel_events.get(task_id)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.soft_cancel","title":"<code>soft_cancel(task_id)</code>  <code>async</code>","text":"<p>Request cooperative cancellation of a task.</p> <p>Sets a cancellation event that the task can check periodically. The task is expected to clean up and exit gracefully.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task to cancel.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if cancellation was requested, False if task not found.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def soft_cancel(self, task_id: str) -&gt; bool:\n    \"\"\"Request cooperative cancellation of a task.\n\n    Sets a cancellation event that the task can check periodically.\n    The task is expected to clean up and exit gracefully.\n\n    Args:\n        task_id: The task to cancel.\n\n    Returns:\n        True if cancellation was requested, False if task not found.\n    \"\"\"\n    if task_id not in self._cancel_events:\n        return False\n\n    self._cancel_events[task_id].set()\n\n    # Send cancel request message\n    if task_id in self.handles:\n        handle = self.handles[task_id]\n        try:\n            await self.message_bus.send(\n                AgentMessage(\n                    type=MessageType.CANCEL_REQUEST,\n                    sender=\"task_manager\",\n                    receiver=handle.subagent_name,\n                    payload={\"reason\": \"soft_cancel\"},\n                    task_id=task_id,\n                )\n            )\n        except KeyError:\n            pass  # Agent not registered, that's OK\n\n    return True\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.hard_cancel","title":"<code>hard_cancel(task_id)</code>  <code>async</code>","text":"<p>Immediately cancel a task.</p> <p>Calls cancel() on the asyncio.Task, causing CancelledError to be raised in the task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task to cancel.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if task was cancelled, False if task not found.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>async def hard_cancel(self, task_id: str) -&gt; bool:\n    \"\"\"Immediately cancel a task.\n\n    Calls cancel() on the asyncio.Task, causing CancelledError\n    to be raised in the task.\n\n    Args:\n        task_id: The task to cancel.\n\n    Returns:\n        True if task was cancelled, False if task not found.\n    \"\"\"\n    if task_id not in self.tasks:\n        return False\n\n    task = self.tasks[task_id]\n    if not task.done():\n        task.cancel()\n\n    # Update handle\n    if task_id in self.handles:\n        handle = self.handles[task_id]\n        handle.status = \"cancelled\"\n        handle.completed_at = datetime.now()\n\n    return True\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.cleanup_task","title":"<code>cleanup_task(task_id)</code>","text":"<p>Clean up resources for a completed task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task to clean up.</p> required Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def cleanup_task(self, task_id: str) -&gt; None:\n    \"\"\"Clean up resources for a completed task.\n\n    Args:\n        task_id: The task to clean up.\n    \"\"\"\n    self.tasks.pop(task_id, None)\n    self._cancel_events.pop(task_id, None)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.TaskManager.list_active_tasks","title":"<code>list_active_tasks()</code>","text":"<p>Get list of active (non-completed) task IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of task IDs for tasks that haven't completed.</p> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def list_active_tasks(self) -&gt; list[str]:\n    \"\"\"Get list of active (non-completed) task IDs.\n\n    Returns:\n        List of task IDs for tasks that haven't completed.\n    \"\"\"\n    return [task_id for task_id, task in self.tasks.items() if not task.done()]\n</code></pre>"},{"location":"api/protocols/#create_message_bus","title":"create_message_bus","text":""},{"location":"api/protocols/#subagents_pydantic_ai.create_message_bus","title":"<code>subagents_pydantic_ai.create_message_bus(backend='memory', **kwargs)</code>","text":"<p>Create a message bus instance.</p> <p>Factory function for creating message bus implementations. Currently only supports in-memory backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend type (\"memory\" is currently supported).</p> <code>'memory'</code> <code>**kwargs</code> <code>Any</code> <p>Backend-specific configuration.</p> <code>{}</code> <p>Returns:</p> Type Description <code>InMemoryMessageBus</code> <p>A message bus instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the backend is not supported.</p> Example Python<pre><code># Create in-memory bus (default)\nbus = create_message_bus()\n\n# Future: Redis bus\n# bus = create_message_bus(\"redis\", url=\"redis://localhost\")\n</code></pre> Source code in <code>src/subagents_pydantic_ai/message_bus.py</code> Python<pre><code>def create_message_bus(backend: str = \"memory\", **kwargs: Any) -&gt; InMemoryMessageBus:\n    \"\"\"Create a message bus instance.\n\n    Factory function for creating message bus implementations.\n    Currently only supports in-memory backend.\n\n    Args:\n        backend: The backend type (\"memory\" is currently supported).\n        **kwargs: Backend-specific configuration.\n\n    Returns:\n        A message bus instance.\n\n    Raises:\n        ValueError: If the backend is not supported.\n\n    Example:\n        ```python\n        # Create in-memory bus (default)\n        bus = create_message_bus()\n\n        # Future: Redis bus\n        # bus = create_message_bus(\"redis\", url=\"redis://localhost\")\n        ```\n    \"\"\"\n    if backend == \"memory\":\n        return InMemoryMessageBus()\n\n    raise ValueError(f\"Unknown message bus backend: {backend}\")\n</code></pre>"},{"location":"api/protocols/#dynamicagentregistry","title":"DynamicAgentRegistry","text":""},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry","title":"<code>subagents_pydantic_ai.DynamicAgentRegistry</code>  <code>dataclass</code>","text":"<p>Registry for dynamically created agents.</p> <p>Provides storage and management for agents created at runtime. Used by the agent factory toolset to track created agents.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>dict[str, Any]</code> <p>Dictionary mapping agent names to Agent instances.</p> <code>configs</code> <code>dict[str, SubAgentConfig]</code> <p>Dictionary mapping agent names to their configurations.</p> <code>max_agents</code> <code>int | None</code> <p>Maximum number of agents allowed (optional limit).</p> Example Python<pre><code>registry = DynamicAgentRegistry(max_agents=10)\n\n# Register a new agent\nregistry.register(config, agent)\n\n# Get an agent\nagent = registry.get(\"my-agent\")\n\n# List all agents\nnames = registry.list_agents()\n\n# Remove an agent\nregistry.remove(\"my-agent\")\n</code></pre> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>@dataclass\nclass DynamicAgentRegistry:\n    \"\"\"Registry for dynamically created agents.\n\n    Provides storage and management for agents created at runtime.\n    Used by the agent factory toolset to track created agents.\n\n    Attributes:\n        agents: Dictionary mapping agent names to Agent instances.\n        configs: Dictionary mapping agent names to their configurations.\n        max_agents: Maximum number of agents allowed (optional limit).\n\n    Example:\n        ```python\n        registry = DynamicAgentRegistry(max_agents=10)\n\n        # Register a new agent\n        registry.register(config, agent)\n\n        # Get an agent\n        agent = registry.get(\"my-agent\")\n\n        # List all agents\n        names = registry.list_agents()\n\n        # Remove an agent\n        registry.remove(\"my-agent\")\n        ```\n    \"\"\"\n\n    agents: dict[str, Any] = field(default_factory=dict)\n    configs: dict[str, SubAgentConfig] = field(default_factory=dict)\n    _compiled: dict[str, CompiledSubAgent] = field(default_factory=dict)\n    max_agents: int | None = None\n\n    def register(\n        self,\n        config: SubAgentConfig,\n        agent: Any,\n    ) -&gt; None:\n        \"\"\"Register a new agent.\n\n        Args:\n            config: The agent's configuration.\n            agent: The Agent instance.\n\n        Raises:\n            ValueError: If agent name already exists or max_agents reached.\n        \"\"\"\n        name = config[\"name\"]\n\n        if name in self.agents:\n            raise ValueError(f\"Agent '{name}' already exists\")\n\n        if self.max_agents and len(self.agents) &gt;= self.max_agents:\n            raise ValueError(\n                f\"Maximum number of agents ({self.max_agents}) reached. \"\n                f\"Remove an agent before creating a new one.\"\n            )\n\n        self.agents[name] = agent\n        self.configs[name] = config\n        self._compiled[name] = CompiledSubAgent(\n            name=name,\n            description=config[\"description\"],\n            agent=agent,\n            config=config,\n        )\n\n    def get(self, name: str) -&gt; Any | None:\n        \"\"\"Get an agent by name.\n\n        Args:\n            name: The agent name.\n\n        Returns:\n            The Agent instance, or None if not found.\n        \"\"\"\n        return self.agents.get(name)\n\n    def get_config(self, name: str) -&gt; SubAgentConfig | None:\n        \"\"\"Get an agent's configuration by name.\n\n        Args:\n            name: The agent name.\n\n        Returns:\n            The SubAgentConfig, or None if not found.\n        \"\"\"\n        return self.configs.get(name)\n\n    def get_compiled(self, name: str) -&gt; CompiledSubAgent | None:\n        \"\"\"Get a compiled agent by name.\n\n        Args:\n            name: The agent name.\n\n        Returns:\n            The CompiledSubAgent, or None if not found.\n        \"\"\"\n        return self._compiled.get(name)\n\n    def remove(self, name: str) -&gt; bool:\n        \"\"\"Remove an agent from the registry.\n\n        Args:\n            name: The agent name to remove.\n\n        Returns:\n            True if agent was removed, False if not found.\n        \"\"\"\n        if name not in self.agents:\n            return False\n\n        del self.agents[name]\n        del self.configs[name]\n        del self._compiled[name]\n        return True\n\n    def list_agents(self) -&gt; list[str]:\n        \"\"\"Get list of all registered agent names.\n\n        Returns:\n            List of agent names.\n        \"\"\"\n        return list(self.agents.keys())\n\n    def list_configs(self) -&gt; list[SubAgentConfig]:\n        \"\"\"Get list of all agent configurations.\n\n        Returns:\n            List of SubAgentConfig for all registered agents.\n        \"\"\"\n        return list(self.configs.values())\n\n    def list_compiled(self) -&gt; list[CompiledSubAgent]:\n        \"\"\"Get list of all compiled agents.\n\n        Returns:\n            List of CompiledSubAgent for all registered agents.\n        \"\"\"\n        return list(self._compiled.values())\n\n    def exists(self, name: str) -&gt; bool:\n        \"\"\"Check if an agent exists.\n\n        Args:\n            name: The agent name.\n\n        Returns:\n            True if agent exists, False otherwise.\n        \"\"\"\n        return name in self.agents\n\n    def count(self) -&gt; int:\n        \"\"\"Get the number of registered agents.\n\n        Returns:\n            Number of agents in the registry.\n        \"\"\"\n        return len(self.agents)\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all agents from the registry.\"\"\"\n        self.agents.clear()\n        self.configs.clear()\n        self._compiled.clear()\n\n    def get_summary(self) -&gt; str:\n        \"\"\"Get a formatted summary of all registered agents.\n\n        Returns:\n            Multi-line string describing all agents.\n        \"\"\"\n        if not self.agents:\n            return \"No dynamically created agents.\"\n\n        lines = [f\"Dynamic Agents ({len(self.agents)}):\"]\n        for name, config in self.configs.items():\n            model = config.get(\"model\", \"default\")\n            lines.append(f\"- {name} [{model}]: {config['description']}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.register","title":"<code>register(config, agent)</code>","text":"<p>Register a new agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SubAgentConfig</code> <p>The agent's configuration.</p> required <code>agent</code> <code>Any</code> <p>The Agent instance.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If agent name already exists or max_agents reached.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def register(\n    self,\n    config: SubAgentConfig,\n    agent: Any,\n) -&gt; None:\n    \"\"\"Register a new agent.\n\n    Args:\n        config: The agent's configuration.\n        agent: The Agent instance.\n\n    Raises:\n        ValueError: If agent name already exists or max_agents reached.\n    \"\"\"\n    name = config[\"name\"]\n\n    if name in self.agents:\n        raise ValueError(f\"Agent '{name}' already exists\")\n\n    if self.max_agents and len(self.agents) &gt;= self.max_agents:\n        raise ValueError(\n            f\"Maximum number of agents ({self.max_agents}) reached. \"\n            f\"Remove an agent before creating a new one.\"\n        )\n\n    self.agents[name] = agent\n    self.configs[name] = config\n    self._compiled[name] = CompiledSubAgent(\n        name=name,\n        description=config[\"description\"],\n        agent=agent,\n        config=config,\n    )\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.get","title":"<code>get(name)</code>","text":"<p>Get an agent by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent name.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The Agent instance, or None if not found.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def get(self, name: str) -&gt; Any | None:\n    \"\"\"Get an agent by name.\n\n    Args:\n        name: The agent name.\n\n    Returns:\n        The Agent instance, or None if not found.\n    \"\"\"\n    return self.agents.get(name)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.get_config","title":"<code>get_config(name)</code>","text":"<p>Get an agent's configuration by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent name.</p> required <p>Returns:</p> Type Description <code>SubAgentConfig | None</code> <p>The SubAgentConfig, or None if not found.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def get_config(self, name: str) -&gt; SubAgentConfig | None:\n    \"\"\"Get an agent's configuration by name.\n\n    Args:\n        name: The agent name.\n\n    Returns:\n        The SubAgentConfig, or None if not found.\n    \"\"\"\n    return self.configs.get(name)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.get_compiled","title":"<code>get_compiled(name)</code>","text":"<p>Get a compiled agent by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent name.</p> required <p>Returns:</p> Type Description <code>CompiledSubAgent | None</code> <p>The CompiledSubAgent, or None if not found.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def get_compiled(self, name: str) -&gt; CompiledSubAgent | None:\n    \"\"\"Get a compiled agent by name.\n\n    Args:\n        name: The agent name.\n\n    Returns:\n        The CompiledSubAgent, or None if not found.\n    \"\"\"\n    return self._compiled.get(name)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.remove","title":"<code>remove(name)</code>","text":"<p>Remove an agent from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent name to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if agent was removed, False if not found.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def remove(self, name: str) -&gt; bool:\n    \"\"\"Remove an agent from the registry.\n\n    Args:\n        name: The agent name to remove.\n\n    Returns:\n        True if agent was removed, False if not found.\n    \"\"\"\n    if name not in self.agents:\n        return False\n\n    del self.agents[name]\n    del self.configs[name]\n    del self._compiled[name]\n    return True\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.list_agents","title":"<code>list_agents()</code>","text":"<p>Get list of all registered agent names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of agent names.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def list_agents(self) -&gt; list[str]:\n    \"\"\"Get list of all registered agent names.\n\n    Returns:\n        List of agent names.\n    \"\"\"\n    return list(self.agents.keys())\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.list_configs","title":"<code>list_configs()</code>","text":"<p>Get list of all agent configurations.</p> <p>Returns:</p> Type Description <code>list[SubAgentConfig]</code> <p>List of SubAgentConfig for all registered agents.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def list_configs(self) -&gt; list[SubAgentConfig]:\n    \"\"\"Get list of all agent configurations.\n\n    Returns:\n        List of SubAgentConfig for all registered agents.\n    \"\"\"\n    return list(self.configs.values())\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.list_compiled","title":"<code>list_compiled()</code>","text":"<p>Get list of all compiled agents.</p> <p>Returns:</p> Type Description <code>list[CompiledSubAgent]</code> <p>List of CompiledSubAgent for all registered agents.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def list_compiled(self) -&gt; list[CompiledSubAgent]:\n    \"\"\"Get list of all compiled agents.\n\n    Returns:\n        List of CompiledSubAgent for all registered agents.\n    \"\"\"\n    return list(self._compiled.values())\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.exists","title":"<code>exists(name)</code>","text":"<p>Check if an agent exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if agent exists, False otherwise.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def exists(self, name: str) -&gt; bool:\n    \"\"\"Check if an agent exists.\n\n    Args:\n        name: The agent name.\n\n    Returns:\n        True if agent exists, False otherwise.\n    \"\"\"\n    return name in self.agents\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.count","title":"<code>count()</code>","text":"<p>Get the number of registered agents.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of agents in the registry.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def count(self) -&gt; int:\n    \"\"\"Get the number of registered agents.\n\n    Returns:\n        Number of agents in the registry.\n    \"\"\"\n    return len(self.agents)\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.clear","title":"<code>clear()</code>","text":"<p>Remove all agents from the registry.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all agents from the registry.\"\"\"\n    self.agents.clear()\n    self.configs.clear()\n    self._compiled.clear()\n</code></pre>"},{"location":"api/protocols/#subagents_pydantic_ai.DynamicAgentRegistry.get_summary","title":"<code>get_summary()</code>","text":"<p>Get a formatted summary of all registered agents.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line string describing all agents.</p> Source code in <code>src/subagents_pydantic_ai/registry.py</code> Python<pre><code>def get_summary(self) -&gt; str:\n    \"\"\"Get a formatted summary of all registered agents.\n\n    Returns:\n        Multi-line string describing all agents.\n    \"\"\"\n    if not self.agents:\n        return \"No dynamically created agents.\"\n\n    lines = [f\"Dynamic Agents ({len(self.agents)}):\"]\n    for name, config in self.configs.items():\n        model = config.get(\"model\", \"default\")\n        lines.append(f\"- {name} [{model}]: {config['description']}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/protocols/#usage-examples","title":"Usage Examples","text":""},{"location":"api/protocols/#implementing-subagentdepsprotocol","title":"Implementing SubAgentDepsProtocol","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\n\n@dataclass\nclass MyDeps:\n    \"\"\"Custom dependencies implementing SubAgentDepsProtocol.\"\"\"\n\n    subagents: dict[str, Any] = field(default_factory=dict)\n    database_url: str = \"\"\n    api_key: str = \"\"\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"MyDeps\":\n        \"\"\"Create isolated deps for subagent.\"\"\"\n        return MyDeps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n            database_url=self.database_url,  # Share read-only config\n            api_key=self.api_key,\n        )\n</code></pre>"},{"location":"api/protocols/#implementing-custom-message-bus","title":"Implementing Custom Message Bus","text":"Python<pre><code>from subagents_pydantic_ai import MessageBusProtocol, AgentMessage\n\nclass RedisMessageBus:\n    \"\"\"Redis-based message bus for distributed systems.\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis = Redis.from_url(redis_url)\n\n    async def send(self, message: AgentMessage) -&gt; None:\n        channel = f\"agent:{message.receiver}\"\n        await self.redis.publish(channel, message.json())\n\n    async def receive(\n        self,\n        agent_id: str,\n        timeout: float | None = None,\n    ) -&gt; AgentMessage | None:\n        # Implementation...\n        pass\n\n    async def subscribe(self, agent_id: str) -&gt; None:\n        pass\n\n    async def unsubscribe(self, agent_id: str) -&gt; None:\n        pass\n</code></pre>"},{"location":"api/protocols/#using-taskmanager","title":"Using TaskManager","text":"Python<pre><code>from subagents_pydantic_ai import TaskManager, InMemoryMessageBus\n\nbus = InMemoryMessageBus()\nmanager = TaskManager(message_bus=bus)\n\n# Create a task\nhandle = await manager.create_task(\n    subagent_name=\"researcher\",\n    description=\"Research Python async\",\n)\n\n# Check status\nstatus = await manager.get_task_status(handle.task_id)\n\n# Answer a question\nawait manager.answer_question(handle.task_id, \"Use asyncio\")\n\n# Cancel a task\nawait manager.cancel_task(handle.task_id, hard=False)\n</code></pre>"},{"location":"api/protocols/#using-dynamicagentregistry","title":"Using DynamicAgentRegistry","text":"Python<pre><code>from subagents_pydantic_ai import DynamicAgentRegistry\n\nregistry = DynamicAgentRegistry()\n\n# List registered agents\nagents = registry.list_agents()\n\n# Get a specific agent\nagent = registry.get_agent(\"custom-analyst\")\n\n# Remove an agent\nregistry.remove_agent(\"custom-analyst\")\n</code></pre>"},{"location":"api/toolset/","title":"Toolset API","text":""},{"location":"api/toolset/#create_subagent_toolset","title":"create_subagent_toolset","text":""},{"location":"api/toolset/#subagents_pydantic_ai.create_subagent_toolset","title":"<code>subagents_pydantic_ai.create_subagent_toolset(subagents=None, default_model='openai:gpt-4.1', toolsets_factory=None, include_general_purpose=True, max_nesting_depth=0, id=None, registry=None, descriptions=None)</code>","text":"<p>Create a toolset for delegating tasks to subagents.</p> <p>This is the main entry point for using the subagent system. It creates a toolset with tools for: - <code>task</code>: Delegate a task to a subagent (sync or async) - <code>check_task</code>: Check status of an async task - <code>answer_subagent</code>: Answer a question from a subagent - <code>list_active_tasks</code>: List all running background tasks - <code>soft_cancel_task</code>: Request cooperative cancellation - <code>hard_cancel_task</code>: Immediately cancel a task</p> <p>Parameters:</p> Name Type Description Default <code>subagents</code> <code>list[SubAgentConfig] | None</code> <p>List of subagent configurations. If None, only general-purpose subagent will be available.</p> <code>None</code> <code>default_model</code> <code>str</code> <p>Default model for subagents that don't specify one.</p> <code>'openai:gpt-4.1'</code> <code>toolsets_factory</code> <code>ToolsetFactory | None</code> <p>Factory function that creates toolsets for subagents. Called with deps when running a task.</p> <code>None</code> <code>include_general_purpose</code> <code>bool</code> <p>Whether to include the default general-purpose subagent. Set to False if you want only specialized subagents.</p> <code>True</code> <code>max_nesting_depth</code> <code>int</code> <p>Maximum depth for nested subagents. 0 means subagents cannot spawn their own subagents.</p> <code>0</code> <code>id</code> <code>str | None</code> <p>Optional toolset ID. Defaults to \"subagents\".</p> <code>None</code> <code>descriptions</code> <code>dict[str, str] | None</code> <p>Optional mapping of tool name to custom description. Keys are tool names (task, check_task, answer_subagent, list_active_tasks, wait_tasks, soft_cancel_task, hard_cancel_task). When provided, the custom description replaces the built-in default.</p> <code>None</code> <p>Returns:</p> Type Description <code>FunctionToolset[Any]</code> <p>FunctionToolset configured with subagent management tools.</p> Example Python<pre><code>from pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"You are a research assistant.\",\n    ),\n]\n\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    default_model=\"openai:gpt-4.1\",\n)\n\nagent = Agent(\"openai:gpt-4.1\", toolsets=[toolset])\n</code></pre> Source code in <code>src/subagents_pydantic_ai/toolset.py</code> Python<pre><code>def create_subagent_toolset(  # noqa: C901\n    subagents: list[SubAgentConfig] | None = None,\n    default_model: str = \"openai:gpt-4.1\",\n    toolsets_factory: ToolsetFactory | None = None,\n    include_general_purpose: bool = True,\n    max_nesting_depth: int = 0,\n    id: str | None = None,\n    registry: Any | None = None,\n    descriptions: dict[str, str] | None = None,\n) -&gt; FunctionToolset[Any]:\n    \"\"\"Create a toolset for delegating tasks to subagents.\n\n    This is the main entry point for using the subagent system. It creates\n    a toolset with tools for:\n    - `task`: Delegate a task to a subagent (sync or async)\n    - `check_task`: Check status of an async task\n    - `answer_subagent`: Answer a question from a subagent\n    - `list_active_tasks`: List all running background tasks\n    - `soft_cancel_task`: Request cooperative cancellation\n    - `hard_cancel_task`: Immediately cancel a task\n\n    Args:\n        subagents: List of subagent configurations. If None, only\n            general-purpose subagent will be available.\n        default_model: Default model for subagents that don't specify one.\n        toolsets_factory: Factory function that creates toolsets for subagents.\n            Called with deps when running a task.\n        include_general_purpose: Whether to include the default general-purpose\n            subagent. Set to False if you want only specialized subagents.\n        max_nesting_depth: Maximum depth for nested subagents. 0 means\n            subagents cannot spawn their own subagents.\n        id: Optional toolset ID. Defaults to \"subagents\".\n        descriptions: Optional mapping of tool name to custom description.\n            Keys are tool names (task, check_task, answer_subagent,\n            list_active_tasks, wait_tasks, soft_cancel_task, hard_cancel_task).\n            When provided, the custom description replaces the built-in default.\n\n    Returns:\n        FunctionToolset configured with subagent management tools.\n\n    Example:\n        ```python\n        from pydantic_ai import Agent\n        from subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n        subagents = [\n            SubAgentConfig(\n                name=\"researcher\",\n                description=\"Researches topics\",\n                instructions=\"You are a research assistant.\",\n            ),\n        ]\n\n        toolset = create_subagent_toolset(\n            subagents=subagents,\n            default_model=\"openai:gpt-4.1\",\n        )\n\n        agent = Agent(\"openai:gpt-4.1\", toolsets=[toolset])\n        ```\n    \"\"\"\n    _descs = descriptions or {}\n\n    # Build subagent configs\n    configs: list[SubAgentConfig] = list(subagents) if subagents else []\n    if include_general_purpose:\n        configs.append(_create_general_purpose_config())\n\n    # Compile subagents\n    compiled: dict[str, CompiledSubAgent] = {}\n    for config in configs:\n        compiled[config[\"name\"]] = _compile_subagent(config, default_model)\n\n    # Create shared state\n    message_bus = InMemoryMessageBus()\n    task_manager = TaskManager(message_bus=message_bus)\n\n    # Build dynamic task description with available subagents\n    subagent_list = \"\\n\".join(f\"- {name}: {c.description}\" for name, c in compiled.items())\n    task_description = _descs.get(\n        \"task\",\n        TASK_TOOL_DESCRIPTION.rstrip() + f\"\\n\\nAvailable subagent types:\\n{subagent_list}\",\n    )\n\n    toolset: FunctionToolset[Any] = FunctionToolset(id=id or \"subagents\")\n\n    @toolset.tool(description=task_description)\n    async def task(\n        ctx: RunContext[SubAgentDepsProtocol],\n        description: str,\n        subagent_type: str,\n        mode: ExecutionMode = \"sync\",\n        priority: TaskPriority = TaskPriority.NORMAL,\n        complexity: Literal[\"simple\", \"moderate\", \"complex\"] | None = None,\n        requires_user_context: bool = False,\n        may_need_clarification: bool = False,\n    ) -&gt; str:\n        \"\"\"Delegate a task to a specialized subagent.\n\n        Args:\n            ctx: The run context with dependencies.\n            description: Detailed description of the task to perform.\n            subagent_type: Name of the subagent to use.\n            mode: Execution mode - \"sync\" (blocking), \"async\" (background), or \"auto\".\n            priority: Task priority level (for async tasks).\n            complexity: Override complexity estimate (\"simple\", \"moderate\", \"complex\").\n            requires_user_context: Whether task needs ongoing user interaction.\n            may_need_clarification: Whether task might need clarifying questions.\n        \"\"\"\n        # Validate subagent_type \u2014 check static compiled dict first, then dynamic registry\n        if subagent_type in compiled:\n            subagent = compiled[subagent_type]\n        elif (\n            registry is not None\n            and hasattr(registry, \"get_compiled\")\n            and registry.get_compiled(subagent_type)\n        ):\n            subagent = registry.get_compiled(subagent_type)\n        else:\n            # Build available list from both sources\n            available_names = list(compiled.keys())\n            if registry is not None and hasattr(registry, \"list_agents\"):\n                available_names.extend(registry.list_agents())\n            available = \", \".join(available_names)\n            return f\"Error: Unknown subagent '{subagent_type}'. Available: {available}\"\n\n        config = subagent.config\n        agent = subagent.agent\n\n        if agent is None:\n            return f\"Error: Subagent '{subagent_type}' is not properly initialized\"\n\n        # Create deps for subagent\n        parent_deps = ctx.deps\n        subagent_deps = parent_deps.clone_for_subagent(max_nesting_depth - 1)\n\n        # Build runtime toolsets from factory if provided\n        runtime_toolsets = toolsets_factory(subagent_deps) if toolsets_factory else None\n\n        # Generate task ID\n        task_id = str(uuid.uuid4())[:8]\n\n        # Resolve mode if \"auto\"\n        if mode == \"auto\":\n            characteristics = TaskCharacteristics(\n                estimated_complexity=complexity or config.get(\"typical_complexity\", \"moderate\"),\n                requires_user_context=requires_user_context\n                or config.get(\"typically_needs_context\", False),\n                may_need_clarification=may_need_clarification,\n            )\n            resolved_mode = decide_execution_mode(characteristics, config)\n        else:\n            resolved_mode = mode\n\n        if resolved_mode == \"sync\":\n            return await _run_sync(\n                agent=agent,\n                config=config,\n                description=description,\n                deps=subagent_deps,\n                task_id=task_id,\n                extra_toolsets=runtime_toolsets,\n            )\n        else:\n            return await _run_async(\n                agent=agent,\n                config=config,\n                description=description,\n                deps=subagent_deps,\n                task_id=task_id,\n                task_manager=task_manager,\n                message_bus=message_bus,\n                extra_toolsets=runtime_toolsets,\n                priority=priority,\n            )\n\n    @toolset.tool(description=_descs.get(\"check_task\", CHECK_TASK_DESCRIPTION))\n    async def check_task(\n        ctx: RunContext[SubAgentDepsProtocol],\n        task_id: str,\n    ) -&gt; str:\n        \"\"\"Check the status of a background task.\n\n        Args:\n            ctx: The run context.\n            task_id: The task ID returned when the task was started.\n        \"\"\"\n        handle = task_manager.get_handle(task_id)\n        if handle is None:\n            return f\"Error: Task '{task_id}' not found\"\n\n        status_info = [\n            f\"Task: {task_id}\",\n            f\"Subagent: {handle.subagent_name}\",\n            f\"Status: {handle.status}\",\n            f\"Description: {handle.description}\",\n        ]\n\n        if handle.status == TaskStatus.COMPLETED:\n            status_info.append(f\"Result: {handle.result}\")\n        elif handle.status == TaskStatus.FAILED:\n            status_info.append(f\"Error: {handle.error}\")\n        elif handle.status == TaskStatus.WAITING_FOR_ANSWER:\n            status_info.append(f\"Question: {handle.pending_question}\")\n        elif handle.started_at:\n            elapsed = (datetime.now() - handle.started_at).total_seconds()\n            status_info.append(f\"Running for: {elapsed:.1f}s\")\n\n        return \"\\n\".join(status_info)\n\n    @toolset.tool(description=_descs.get(\"answer_subagent\", ANSWER_SUBAGENT_DESCRIPTION))\n    async def answer_subagent(\n        ctx: RunContext[SubAgentDepsProtocol],\n        task_id: str,\n        answer: str,\n    ) -&gt; str:\n        \"\"\"Answer a question from a subagent.\n\n        Args:\n            ctx: The run context.\n            task_id: The task ID of the waiting subagent.\n            answer: Your answer to the subagent's question.\n        \"\"\"\n        handle = task_manager.get_handle(task_id)\n        if handle is None:\n            return f\"Error: Task '{task_id}' not found\"\n\n        if handle.status != TaskStatus.WAITING_FOR_ANSWER:\n            return f\"Error: Task '{task_id}' is not waiting for an answer (status: {handle.status})\"\n\n        # Find the pending question message and answer it\n        try:\n            # Create answer message\n            answer_msg = AgentMessage(\n                type=MessageType.ANSWER,\n                sender=\"parent\",\n                receiver=handle.subagent_name,\n                payload=answer,\n                task_id=task_id,\n            )\n            await message_bus.send(answer_msg)\n\n            # Update handle status\n            handle.status = TaskStatus.RUNNING\n            handle.pending_question = None\n\n            return f\"Answer sent to task '{task_id}'\"\n        except KeyError:\n            return \"Error: Could not send answer - subagent not available\"\n\n    @toolset.tool(description=_descs.get(\"list_active_tasks\", LIST_ACTIVE_TASKS_DESCRIPTION))\n    async def list_active_tasks(\n        ctx: RunContext[SubAgentDepsProtocol],\n    ) -&gt; str:\n        \"\"\"List all active background tasks.\"\"\"\n        active_ids = task_manager.list_active_tasks()\n\n        if not active_ids:\n            return \"No active background tasks.\"\n\n        lines = [\"Active background tasks:\"]\n        for tid in active_ids:\n            handle = task_manager.get_handle(tid)\n            if handle:  # pragma: no branch\n                desc = handle.description[:50]\n                lines.append(f\"- {tid}: {handle.subagent_name} ({handle.status}) - {desc}...\")\n\n        return \"\\n\".join(lines)\n\n    @toolset.tool(description=_descs.get(\"wait_tasks\", WAIT_TASKS_DESCRIPTION))\n    async def wait_tasks(\n        ctx: RunContext[SubAgentDepsProtocol],\n        task_ids: list[str],\n        timeout: float = 300.0,\n    ) -&gt; str:\n        \"\"\"Wait for multiple background tasks to complete.\n\n        Args:\n            ctx: The run context.\n            task_ids: List of task IDs to wait for.\n            timeout: Maximum seconds to wait (default 300s / 5 minutes).\n        \"\"\"\n        # Collect asyncio.Task objects for the requested task_ids\n        tasks_to_await: list[tuple[str, asyncio.Task[Any]]] = []\n        for tid in task_ids:\n            t = task_manager.tasks.get(tid)\n            if t is not None and not t.done():\n                tasks_to_await.append((tid, t))\n\n        # Wait for all with timeout\n        if tasks_to_await:\n            aws = [t for _, t in tasks_to_await]\n            try:\n                await asyncio.wait_for(\n                    asyncio.gather(*aws, return_exceptions=True),\n                    timeout=timeout,\n                )\n            except asyncio.TimeoutError:\n                pass  # Report what we have so far\n\n        # Collect results\n        lines: list[str] = []\n        for tid in task_ids:\n            handle = task_manager.get_handle(tid)\n            if handle is None:\n                lines.append(f\"- {tid}: not found\")\n                continue\n            status = handle.status\n            if status == \"completed\":\n                result_preview = (handle.result or \"\")[:2000]\n                lines.append(f\"- {tid} ({handle.subagent_name}): COMPLETED\\n{result_preview}\")\n            elif status == \"failed\":\n                lines.append(f\"- {tid} ({handle.subagent_name}): FAILED - {handle.error}\")\n            else:\n                lines.append(f\"- {tid} ({handle.subagent_name}): {status}\")\n\n        return \"Task results:\\n\" + \"\\n\\n\".join(lines)\n\n    @toolset.tool(description=_descs.get(\"soft_cancel_task\", SOFT_CANCEL_TASK_DESCRIPTION))\n    async def soft_cancel_task(\n        ctx: RunContext[SubAgentDepsProtocol],\n        task_id: str,\n    ) -&gt; str:\n        \"\"\"Request cooperative cancellation of a background task.\n\n        Args:\n            ctx: The run context.\n            task_id: The task to cancel.\n        \"\"\"\n        success = await task_manager.soft_cancel(task_id)\n        if success:\n            return f\"Cancellation requested for task '{task_id}'\"\n        return f\"Error: Task '{task_id}' not found\"\n\n    @toolset.tool(description=_descs.get(\"hard_cancel_task\", HARD_CANCEL_TASK_DESCRIPTION))\n    async def hard_cancel_task(\n        ctx: RunContext[SubAgentDepsProtocol],\n        task_id: str,\n    ) -&gt; str:\n        \"\"\"Immediately cancel a background task.\n\n        Args:\n            ctx: The run context.\n            task_id: The task to cancel.\n        \"\"\"\n        success = await task_manager.hard_cancel(task_id)\n        if success:\n            return f\"Task '{task_id}' has been cancelled\"\n        return f\"Error: Task '{task_id}' not found\"\n\n    # Expose task_manager for external monitoring (e.g., push notifications)\n    toolset.task_manager = task_manager  # type: ignore[attr-defined]\n\n    return toolset\n</code></pre>"},{"location":"api/toolset/#create_agent_factory_toolset","title":"create_agent_factory_toolset","text":""},{"location":"api/toolset/#subagents_pydantic_ai.create_agent_factory_toolset","title":"<code>subagents_pydantic_ai.create_agent_factory_toolset(registry, allowed_models=None, default_model='openai:gpt-4.1', max_agents=10, toolsets_factory=None, capabilities_map=None, id=None)</code>","text":"<p>Create a toolset for dynamic agent creation.</p> <p>This toolset provides tools for creating, listing, and removing agents at runtime. Created agents are stored in the provided registry and can be used with the main subagent toolset.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>DynamicAgentRegistry</code> <p>Registry to store created agents.</p> required <code>allowed_models</code> <code>list[str] | None</code> <p>List of allowed model names. If None, any model is allowed.</p> <code>None</code> <code>default_model</code> <code>str</code> <p>Default model to use when not specified.</p> <code>'openai:gpt-4.1'</code> <code>max_agents</code> <code>int</code> <p>Maximum number of dynamic agents allowed.</p> <code>10</code> <code>toolsets_factory</code> <code>ToolsetFactory | None</code> <p>Factory to create toolsets for new agents. Takes priority over capabilities if both are provided.</p> <code>None</code> <code>capabilities_map</code> <code>dict[str, CapabilityFactory] | None</code> <p>Mapping of capability names to factory functions. E.g., {\"filesystem\": create_fs_toolset, \"todo\": create_todo_toolset}. Used when capabilities are specified in create_agent.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>Optional toolset ID. Defaults to \"agent_factory\".</p> <code>None</code> <p>Returns:</p> Type Description <code>FunctionToolset[Any]</code> <p>FunctionToolset with agent management tools.</p> Example Python<pre><code>from pydantic_ai import Agent\nfrom subagents_pydantic_ai import (\n    create_agent_factory_toolset,\n    DynamicAgentRegistry,\n)\n\nregistry = DynamicAgentRegistry()\n\n# With capabilities map\nfactory_toolset = create_agent_factory_toolset(\n    registry=registry,\n    allowed_models=[\"openai:gpt-4.1\", \"openai:gpt-4o-mini\"],\n    max_agents=5,\n    capabilities_map={\n        \"filesystem\": lambda deps: [create_fs_toolset(deps.backend)],\n        \"todo\": lambda deps: [create_todo_toolset()],\n    },\n)\n\nagent = Agent(\"openai:gpt-4.1\", toolsets=[factory_toolset])\n</code></pre> Source code in <code>src/subagents_pydantic_ai/factory.py</code> Python<pre><code>def create_agent_factory_toolset(\n    registry: DynamicAgentRegistry,\n    allowed_models: list[str] | None = None,\n    default_model: str = \"openai:gpt-4.1\",\n    max_agents: int = 10,\n    toolsets_factory: ToolsetFactory | None = None,\n    capabilities_map: dict[str, CapabilityFactory] | None = None,\n    id: str | None = None,\n) -&gt; FunctionToolset[Any]:\n    \"\"\"Create a toolset for dynamic agent creation.\n\n    This toolset provides tools for creating, listing, and removing\n    agents at runtime. Created agents are stored in the provided\n    registry and can be used with the main subagent toolset.\n\n    Args:\n        registry: Registry to store created agents.\n        allowed_models: List of allowed model names. If None, any model\n            is allowed.\n        default_model: Default model to use when not specified.\n        max_agents: Maximum number of dynamic agents allowed.\n        toolsets_factory: Factory to create toolsets for new agents.\n            Takes priority over capabilities if both are provided.\n        capabilities_map: Mapping of capability names to factory functions.\n            E.g., {\"filesystem\": create_fs_toolset, \"todo\": create_todo_toolset}.\n            Used when capabilities are specified in create_agent.\n        id: Optional toolset ID. Defaults to \"agent_factory\".\n\n    Returns:\n        FunctionToolset with agent management tools.\n\n    Example:\n        ```python\n        from pydantic_ai import Agent\n        from subagents_pydantic_ai import (\n            create_agent_factory_toolset,\n            DynamicAgentRegistry,\n        )\n\n        registry = DynamicAgentRegistry()\n\n        # With capabilities map\n        factory_toolset = create_agent_factory_toolset(\n            registry=registry,\n            allowed_models=[\"openai:gpt-4.1\", \"openai:gpt-4o-mini\"],\n            max_agents=5,\n            capabilities_map={\n                \"filesystem\": lambda deps: [create_fs_toolset(deps.backend)],\n                \"todo\": lambda deps: [create_todo_toolset()],\n            },\n        )\n\n        agent = Agent(\"openai:gpt-4.1\", toolsets=[factory_toolset])\n        ```\n    \"\"\"\n    # Update registry max_agents\n    registry.max_agents = max_agents\n\n    # Format allowed models for docstring\n    models_desc = (\n        f\"Allowed models: {', '.join(allowed_models)}\" if allowed_models else \"Any model is allowed\"\n    )\n\n    # Format available capabilities for docstring\n    caps_desc = (\n        f\"Available capabilities: {', '.join(capabilities_map.keys())}\"\n        if capabilities_map\n        else \"No predefined capabilities available\"\n    )\n\n    toolset: FunctionToolset[Any] = FunctionToolset(id=id or \"agent_factory\")\n\n    @toolset.tool\n    async def create_agent(\n        ctx: RunContext[SubAgentDepsProtocol],\n        name: str,\n        description: str,\n        instructions: str,\n        model: str | None = None,\n        capabilities: list[str] | None = None,\n        can_ask_questions: bool = True,\n    ) -&gt; str:\n        f\"\"\"Create a new specialized agent at runtime.\n\n        Creates a new agent with the specified configuration. The agent\n        will be available for delegation via the task tool.\n\n        {models_desc}\n        {caps_desc}\n\n        Args:\n            ctx: The run context.\n            name: Unique name for the agent (letters, numbers, hyphens only).\n            description: Brief description of what the agent does.\n            instructions: System prompt / instructions for the agent.\n            model: Model to use (optional, defaults to {default_model}).\n            capabilities: List of capability names to enable (e.g., [\"filesystem\", \"todo\"]).\n            can_ask_questions: Whether agent can ask parent questions.\n\n        Returns:\n            Confirmation message or error.\n        \"\"\"\n        # Validate name\n        if not name or not all(c.isalnum() or c == \"-\" for c in name):\n            return \"Error: Name must contain only letters, numbers, and hyphens\"\n\n        if registry.exists(name):\n            return f\"Error: Agent '{name}' already exists\"\n\n        # Validate model\n        actual_model = model or default_model\n        if allowed_models and actual_model not in allowed_models:\n            allowed = \", \".join(allowed_models)\n            return f\"Error: Model '{actual_model}' is not allowed. Use one of: {allowed}\"\n\n        # Validate capabilities\n        if capabilities and capabilities_map:\n            invalid_caps = [c for c in capabilities if c not in capabilities_map]\n            if invalid_caps:\n                available = \", \".join(capabilities_map.keys())\n                invalid = \", \".join(invalid_caps)\n                return f\"Error: Unknown capabilities: {invalid}. Available: {available}\"\n\n        # Create config\n        config = SubAgentConfig(\n            name=name,\n            description=description,\n            instructions=instructions,\n            model=actual_model,\n            can_ask_questions=can_ask_questions,\n        )\n\n        # Collect toolsets\n        agent_toolsets: list[Any] = []\n        if toolsets_factory:\n            agent_toolsets.extend(toolsets_factory(ctx.deps))\n        elif capabilities and capabilities_map:\n            for cap_name in capabilities:\n                cap_factory = capabilities_map[cap_name]\n                agent_toolsets.extend(cap_factory(ctx.deps))\n\n        # Create agent\n        try:\n            agent: Agent[Any, str] = Agent(\n                actual_model,\n                system_prompt=instructions,\n                toolsets=agent_toolsets or None,\n            )\n\n            registry.register(config, agent)\n\n            caps_info = f\"\\nCapabilities: {', '.join(capabilities)}\" if capabilities else \"\"\n            return (\n                f\"Agent '{name}' created successfully.\\n\"\n                f\"Model: {actual_model}\\n\"\n                f\"Description: {description}{caps_info}\\n\"\n                f\"Use task(description, '{name}') to delegate tasks.\"\n            )\n\n        except ValueError as e:\n            return f\"Error: {e}\"\n        except Exception as e:\n            return f\"Error creating agent: {e}\"\n\n    @toolset.tool\n    async def list_agents(\n        ctx: RunContext[SubAgentDepsProtocol],\n    ) -&gt; str:\n        \"\"\"List all dynamically created agents.\n\n        Returns:\n            List of agent names and descriptions.\n        \"\"\"\n        return registry.get_summary()\n\n    @toolset.tool\n    async def remove_agent(\n        ctx: RunContext[SubAgentDepsProtocol],\n        name: str,\n    ) -&gt; str:\n        \"\"\"Remove a dynamically created agent.\n\n        The agent will no longer be available for task delegation.\n\n        Args:\n            ctx: The run context.\n            name: Name of the agent to remove.\n\n        Returns:\n            Confirmation or error message.\n        \"\"\"\n        if registry.remove(name):\n            return f\"Agent '{name}' has been removed.\"\n        return f\"Error: Agent '{name}' not found.\"\n\n    @toolset.tool\n    async def get_agent_info(\n        ctx: RunContext[SubAgentDepsProtocol],\n        name: str,\n    ) -&gt; str:\n        \"\"\"Get detailed information about a dynamic agent.\n\n        Args:\n            ctx: The run context.\n            name: Name of the agent.\n\n        Returns:\n            Agent details or error message.\n        \"\"\"\n        config = registry.get_config(name)\n        if config is None:\n            return f\"Error: Agent '{name}' not found.\"\n\n        info = [\n            f\"Agent: {name}\",\n            f\"Description: {config['description']}\",\n            f\"Model: {config.get('model', default_model)}\",\n            f\"Can ask questions: {config.get('can_ask_questions', True)}\",\n            \"\",\n            \"Instructions:\",\n            config[\"instructions\"][:500] + (\"...\" if len(config[\"instructions\"]) &gt; 500 else \"\"),\n        ]\n\n        return \"\\n\".join(info)\n\n    return toolset\n</code></pre>"},{"location":"api/toolset/#subagenttoolset","title":"SubAgentToolset","text":""},{"location":"api/toolset/#subagents_pydantic_ai.SubAgentToolset","title":"<code>subagents_pydantic_ai.SubAgentToolset = create_subagent_toolset</code>  <code>module-attribute</code>","text":""},{"location":"api/toolset/#get_subagent_system_prompt","title":"get_subagent_system_prompt","text":""},{"location":"api/toolset/#subagents_pydantic_ai.get_subagent_system_prompt","title":"<code>subagents_pydantic_ai.get_subagent_system_prompt(configs, include_dual_mode=True)</code>","text":"<p>Generate system prompt section describing available subagents.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>list[SubAgentConfig]</code> <p>List of subagent configurations.</p> required <code>include_dual_mode</code> <code>bool</code> <p>Whether to include dual-mode execution explanation.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted system prompt section.</p> Example Python<pre><code>configs = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"...\",\n    ),\n]\nprompt = get_subagent_system_prompt(configs)\n</code></pre> Source code in <code>src/subagents_pydantic_ai/prompts.py</code> Python<pre><code>def get_subagent_system_prompt(\n    configs: list[SubAgentConfig],\n    include_dual_mode: bool = True,\n) -&gt; str:\n    \"\"\"Generate system prompt section describing available subagents.\n\n    Args:\n        configs: List of subagent configurations.\n        include_dual_mode: Whether to include dual-mode execution explanation.\n\n    Returns:\n        Formatted system prompt section.\n\n    Example:\n        ```python\n        configs = [\n            SubAgentConfig(\n                name=\"researcher\",\n                description=\"Researches topics\",\n                instructions=\"...\",\n            ),\n        ]\n        prompt = get_subagent_system_prompt(configs)\n        ```\n    \"\"\"\n    lines = [\"## Available Subagents\", \"\"]\n    lines.append(\"Use the `task` tool to delegate work to these subagents:\")\n    lines.append(\"\")\n\n    for config in configs:\n        name = config[\"name\"]\n        description = config[\"description\"]\n        lines.append(f\"- **{name}**: {description}\")\n\n        # Add hint if agent cannot ask questions\n        if config.get(\"can_ask_questions\") is False:\n            lines[-1] += \" *(cannot ask clarifying questions)*\"\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/toolset/#get_task_instructions_prompt","title":"get_task_instructions_prompt","text":""},{"location":"api/toolset/#subagents_pydantic_ai.get_task_instructions_prompt","title":"<code>subagents_pydantic_ai.get_task_instructions_prompt(task_description, can_ask_questions=True, max_questions=None)</code>","text":"<p>Generate the task instructions for a subagent.</p> <p>Parameters:</p> Name Type Description Default <code>task_description</code> <code>str</code> <p>The task to perform.</p> required <code>can_ask_questions</code> <code>bool</code> <p>Whether the subagent can ask the parent questions.</p> <code>True</code> <code>max_questions</code> <code>int | None</code> <p>Maximum number of questions allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted task instructions.</p> Source code in <code>src/subagents_pydantic_ai/prompts.py</code> Python<pre><code>def get_task_instructions_prompt(\n    task_description: str,\n    can_ask_questions: bool = True,\n    max_questions: int | None = None,\n) -&gt; str:\n    \"\"\"Generate the task instructions for a subagent.\n\n    Args:\n        task_description: The task to perform.\n        can_ask_questions: Whether the subagent can ask the parent questions.\n        max_questions: Maximum number of questions allowed.\n\n    Returns:\n        Formatted task instructions.\n    \"\"\"\n    lines = [\"## Your Task\", \"\", task_description, \"\"]\n\n    if can_ask_questions:\n        lines.append(\"## Asking Questions\")\n        lines.append(\"If you need clarification, use the `ask_parent` tool.\")\n        if max_questions is not None:\n            lines.append(f\"You may ask up to {max_questions} questions.\")\n        lines.append(\"Keep questions specific and essential.\")\n    else:\n        lines.append(\"## Note\")\n        lines.append(\"Complete this task using your best judgment.\")\n        lines.append(\"You cannot ask the parent for clarification.\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/toolset/#usage-example","title":"Usage Example","text":"Python<pre><code>from subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n# Define subagents\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"You research topics thoroughly.\",\n    ),\n    SubAgentConfig(\n        name=\"writer\",\n        description=\"Writes content\",\n        instructions=\"You write clear content.\",\n    ),\n]\n\n# Create toolset\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    default_model=\"openai:gpt-4o\",\n    max_nesting_depth=1,\n)\n\n# Add to agent\nfrom pydantic_ai import Agent\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n)\n</code></pre>"},{"location":"api/toolset/#with-custom-tool-descriptions","title":"With Custom Tool Descriptions","text":"<p>Override default tool descriptions for better LLM behavior:</p> Python<pre><code>toolset = create_subagent_toolset(\n    subagents=subagents,\n    descriptions={\n        \"task\": \"Assign a task to a specialized subagent\",\n        \"check_task\": \"Check the status of a delegated task\",\n        \"list_active_tasks\": \"Show all currently running background tasks\",\n    },\n)\n</code></pre> <p>Available tool names: <code>task</code>, <code>check_task</code>, <code>answer_subagent</code>, <code>list_active_tasks</code>, <code>wait_tasks</code>, <code>soft_cancel_task</code>, <code>hard_cancel_task</code>.</p>"},{"location":"api/toolset/#with-toolsets-factory","title":"With Toolsets Factory","text":"Python<pre><code>from pydantic_ai_backends import create_console_toolset\n\ndef my_toolsets_factory(deps):\n    return [create_console_toolset()]\n\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    toolsets_factory=my_toolsets_factory,\n)\n</code></pre>"},{"location":"api/toolset/#with-dynamic-agent-creation","title":"With Dynamic Agent Creation","text":"Python<pre><code>from subagents_pydantic_ai import (\n    create_subagent_toolset,\n    create_agent_factory_toolset,\n    DynamicAgentRegistry,\n)\n\nregistry = DynamicAgentRegistry()\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[\n        create_subagent_toolset(subagents=subagents),\n        create_agent_factory_toolset(\n            registry=registry,\n            allowed_models=[\"openai:gpt-4o\", \"openai:gpt-4o-mini\"],\n            max_agents=5,\n        ),\n    ],\n)\n</code></pre>"},{"location":"api/types/","title":"Types API","text":""},{"location":"api/types/#subagentconfig","title":"SubAgentConfig","text":""},{"location":"api/types/#subagents_pydantic_ai.SubAgentConfig","title":"<code>subagents_pydantic_ai.SubAgentConfig</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration for a subagent.</p> <p>Defines the name, description, and instructions for a subagent. Used by the toolset to create agent instances.</p> Required fields <p>name: Unique identifier for the subagent description: Brief description shown to parent agent instructions: System prompt for the subagent</p> Optional fields <p>model: LLM model to use (defaults to parent's default) can_ask_questions: Whether subagent can ask parent questions max_questions: Maximum questions per task preferred_mode: Default execution mode preference for this subagent typical_complexity: Typical task complexity for this subagent typically_needs_context: Whether this subagent typically needs user context toolsets: Additional toolsets to register with the subagent agent_kwargs: Additional kwargs passed to Agent constructor (e.g., builtin_tools) context_files: List of context file paths in the backend.     When used with pydantic-deep, these are loaded via ContextToolset     and injected into this subagent's system prompt. Each subagent     can have its own context files. extra: Generic extensibility dict for consumer libraries.     subagents-pydantic-ai does not read this field \u2014 it's carried     through for consumers like pydantic-deep to use freely.     Example keys: <code>memory</code>, <code>team</code>, <code>cost_budget</code>.</p> Example with builtin_tools Python<pre><code>SubAgentConfig(\n    name=\"researcher\",\n    description=\"Research agent with web search\",\n    instructions=\"You research topics using web search.\",\n    agent_kwargs={\"builtin_tools\": [BuitinTools.web_search]},\n)\n</code></pre> Example with per-subagent context Python<pre><code>SubAgentConfig(\n    name=\"coder\",\n    description=\"Code writer\",\n    instructions=\"You write code following project rules.\",\n    context_files=[\"/agents/coder/AGENTS.md\", \"/CODING_RULES.md\"],\n)\n</code></pre> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>class SubAgentConfig(TypedDict, total=False):\n    \"\"\"Configuration for a subagent.\n\n    Defines the name, description, and instructions for a subagent.\n    Used by the toolset to create agent instances.\n\n    Required fields:\n        name: Unique identifier for the subagent\n        description: Brief description shown to parent agent\n        instructions: System prompt for the subagent\n\n    Optional fields:\n        model: LLM model to use (defaults to parent's default)\n        can_ask_questions: Whether subagent can ask parent questions\n        max_questions: Maximum questions per task\n        preferred_mode: Default execution mode preference for this subagent\n        typical_complexity: Typical task complexity for this subagent\n        typically_needs_context: Whether this subagent typically needs user context\n        toolsets: Additional toolsets to register with the subagent\n        agent_kwargs: Additional kwargs passed to Agent constructor (e.g., builtin_tools)\n        context_files: List of context file paths in the backend.\n            When used with pydantic-deep, these are loaded via ContextToolset\n            and injected into this subagent's system prompt. Each subagent\n            can have its own context files.\n        extra: Generic extensibility dict for consumer libraries.\n            subagents-pydantic-ai does not read this field \u2014 it's carried\n            through for consumers like pydantic-deep to use freely.\n            Example keys: ``memory``, ``team``, ``cost_budget``.\n\n    Example with builtin_tools:\n        ```python\n        SubAgentConfig(\n            name=\"researcher\",\n            description=\"Research agent with web search\",\n            instructions=\"You research topics using web search.\",\n            agent_kwargs={\"builtin_tools\": [BuitinTools.web_search]},\n        )\n        ```\n\n    Example with per-subagent context:\n        ```python\n        SubAgentConfig(\n            name=\"coder\",\n            description=\"Code writer\",\n            instructions=\"You write code following project rules.\",\n            context_files=[\"/agents/coder/AGENTS.md\", \"/CODING_RULES.md\"],\n        )\n        ```\n    \"\"\"\n\n    name: str\n    description: str\n    instructions: str\n    model: NotRequired[str]\n    can_ask_questions: NotRequired[bool]\n    max_questions: NotRequired[int]\n    preferred_mode: NotRequired[Literal[\"sync\", \"async\", \"auto\"]]\n    typical_complexity: NotRequired[Literal[\"simple\", \"moderate\", \"complex\"]]\n    typically_needs_context: NotRequired[bool]\n    toolsets: NotRequired[list[Any]]\n    agent_kwargs: NotRequired[dict[str, Any]]\n    context_files: NotRequired[list[str]]\n    extra: NotRequired[dict[str, Any]]\n</code></pre>"},{"location":"api/types/#compiledsubagent","title":"CompiledSubAgent","text":""},{"location":"api/types/#subagents_pydantic_ai.CompiledSubAgent","title":"<code>subagents_pydantic_ai.CompiledSubAgent</code>  <code>dataclass</code>","text":"<p>A pre-compiled subagent ready for use.</p> <p>After processing SubAgentConfig, the toolset creates a CompiledSubAgent that includes the actual agent instance.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the subagent.</p> <code>description</code> <code>str</code> <p>Brief description of the subagent's purpose.</p> <code>agent</code> <code>object | None</code> <p>The actual agent instance.</p> <code>config</code> <code>SubAgentConfig</code> <p>The original configuration used to create this agent.</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>@dataclass\nclass CompiledSubAgent:\n    \"\"\"A pre-compiled subagent ready for use.\n\n    After processing SubAgentConfig, the toolset creates a CompiledSubAgent\n    that includes the actual agent instance.\n\n    Attributes:\n        name: Unique identifier for the subagent.\n        description: Brief description of the subagent's purpose.\n        agent: The actual agent instance.\n        config: The original configuration used to create this agent.\n    \"\"\"\n\n    name: str\n    description: str\n    config: SubAgentConfig\n    agent: object | None = None  # Agent instance - typed as object to avoid circular imports\n</code></pre>"},{"location":"api/types/#taskhandle","title":"TaskHandle","text":""},{"location":"api/types/#subagents_pydantic_ai.TaskHandle","title":"<code>subagents_pydantic_ai.TaskHandle</code>  <code>dataclass</code>","text":"<p>Handle for managing a background task.</p> <p>Returned when a task is started in async mode. Use this to check status, get results, or cancel the task.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>Unique identifier for the task</p> <code>subagent_name</code> <code>str</code> <p>Name of the subagent executing the task</p> <code>description</code> <code>str</code> <p>Task description</p> <code>status</code> <code>TaskStatus</code> <p>Current task status</p> <code>priority</code> <code>TaskPriority</code> <p>Task priority level</p> <code>created_at</code> <code>datetime</code> <p>When the task was created</p> <code>started_at</code> <code>datetime | None</code> <p>When execution started</p> <code>completed_at</code> <code>datetime | None</code> <p>When execution finished</p> <code>result</code> <code>str | None</code> <p>Task result (if completed)</p> <code>error</code> <code>str | None</code> <p>Error message (if failed)</p> <code>pending_question</code> <code>str | None</code> <p>Question waiting for answer (if any)</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>@dataclass\nclass TaskHandle:\n    \"\"\"Handle for managing a background task.\n\n    Returned when a task is started in async mode. Use this to\n    check status, get results, or cancel the task.\n\n    Attributes:\n        task_id: Unique identifier for the task\n        subagent_name: Name of the subagent executing the task\n        description: Task description\n        status: Current task status\n        priority: Task priority level\n        created_at: When the task was created\n        started_at: When execution started\n        completed_at: When execution finished\n        result: Task result (if completed)\n        error: Error message (if failed)\n        pending_question: Question waiting for answer (if any)\n    \"\"\"\n\n    task_id: str\n    subagent_name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    priority: TaskPriority = TaskPriority.NORMAL\n    created_at: datetime = field(default_factory=datetime.now)\n    started_at: datetime | None = None\n    completed_at: datetime | None = None\n    result: str | None = None\n    error: str | None = None\n    pending_question: str | None = None\n</code></pre>"},{"location":"api/types/#taskstatus","title":"TaskStatus","text":""},{"location":"api/types/#subagents_pydantic_ai.TaskStatus","title":"<code>subagents_pydantic_ai.TaskStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a background task.</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>class TaskStatus(str, Enum):\n    \"\"\"Status of a background task.\"\"\"\n\n    PENDING = \"pending\"\n    \"\"\"Task is queued but not started.\"\"\"\n\n    RUNNING = \"running\"\n    \"\"\"Task is currently executing.\"\"\"\n\n    WAITING_FOR_ANSWER = \"waiting_for_answer\"\n    \"\"\"Task is blocked waiting for parent response.\"\"\"\n\n    COMPLETED = \"completed\"\n    \"\"\"Task finished successfully.\"\"\"\n\n    FAILED = \"failed\"\n    \"\"\"Task failed with an error.\"\"\"\n\n    CANCELLED = \"cancelled\"\n    \"\"\"Task was cancelled.\"\"\"\n</code></pre>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.PENDING","title":"<code>PENDING = 'pending'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task is queued but not started.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.RUNNING","title":"<code>RUNNING = 'running'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task is currently executing.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.WAITING_FOR_ANSWER","title":"<code>WAITING_FOR_ANSWER = 'waiting_for_answer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task is blocked waiting for parent response.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.COMPLETED","title":"<code>COMPLETED = 'completed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task finished successfully.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.FAILED","title":"<code>FAILED = 'failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task failed with an error.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskStatus.CANCELLED","title":"<code>CANCELLED = 'cancelled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task was cancelled.</p>"},{"location":"api/types/#taskpriority","title":"TaskPriority","text":""},{"location":"api/types/#subagents_pydantic_ai.TaskPriority","title":"<code>subagents_pydantic_ai.TaskPriority</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Priority levels for background tasks.</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>class TaskPriority(str, Enum):\n    \"\"\"Priority levels for background tasks.\"\"\"\n\n    LOW = \"low\"\n    \"\"\"Low priority task, can be deferred.\"\"\"\n\n    NORMAL = \"normal\"\n    \"\"\"Normal priority task (default).\"\"\"\n\n    HIGH = \"high\"\n    \"\"\"High priority task, should be processed soon.\"\"\"\n\n    CRITICAL = \"critical\"\n    \"\"\"Critical priority task, process immediately.\"\"\"\n</code></pre>"},{"location":"api/types/#subagents_pydantic_ai.TaskPriority.LOW","title":"<code>LOW = 'low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Low priority task, can be deferred.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskPriority.NORMAL","title":"<code>NORMAL = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Normal priority task (default).</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskPriority.HIGH","title":"<code>HIGH = 'high'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>High priority task, should be processed soon.</p>"},{"location":"api/types/#subagents_pydantic_ai.TaskPriority.CRITICAL","title":"<code>CRITICAL = 'critical'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Critical priority task, process immediately.</p>"},{"location":"api/types/#executionmode","title":"ExecutionMode","text":""},{"location":"api/types/#subagents_pydantic_ai.ExecutionMode","title":"<code>subagents_pydantic_ai.ExecutionMode = Literal['sync', 'async', 'auto']</code>  <code>module-attribute</code>","text":"<p>Execution mode for subagent tasks.</p> <ul> <li>sync: Execute synchronously, blocking until completion (default)</li> <li>async: Execute in background, return immediately with task handle</li> <li>auto: Automatically decide based on task characteristics</li> </ul>"},{"location":"api/types/#taskcharacteristics","title":"TaskCharacteristics","text":""},{"location":"api/types/#subagents_pydantic_ai.TaskCharacteristics","title":"<code>subagents_pydantic_ai.TaskCharacteristics</code>  <code>dataclass</code>","text":"<p>Characteristics that help decide execution mode.</p> <p>These characteristics are used by <code>decide_execution_mode</code> to automatically select between sync and async execution based on task properties.</p> <p>Attributes:</p> Name Type Description <code>estimated_complexity</code> <code>Literal['simple', 'moderate', 'complex']</code> <p>Expected task complexity level.</p> <code>requires_user_context</code> <code>bool</code> <p>Whether task needs ongoing user interaction.</p> <code>is_time_sensitive</code> <code>bool</code> <p>Whether quick response is important.</p> <code>can_run_independently</code> <code>bool</code> <p>Whether task can complete without further input.</p> <code>may_need_clarification</code> <code>bool</code> <p>Whether task might need clarifying questions.</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>@dataclass\nclass TaskCharacteristics:\n    \"\"\"Characteristics that help decide execution mode.\n\n    These characteristics are used by `decide_execution_mode` to automatically\n    select between sync and async execution based on task properties.\n\n    Attributes:\n        estimated_complexity: Expected task complexity level.\n        requires_user_context: Whether task needs ongoing user interaction.\n        is_time_sensitive: Whether quick response is important.\n        can_run_independently: Whether task can complete without further input.\n        may_need_clarification: Whether task might need clarifying questions.\n    \"\"\"\n\n    estimated_complexity: Literal[\"simple\", \"moderate\", \"complex\"] = \"moderate\"\n    requires_user_context: bool = False\n    is_time_sensitive: bool = False\n    can_run_independently: bool = True\n    may_need_clarification: bool = False\n</code></pre>"},{"location":"api/types/#agentmessage","title":"AgentMessage","text":""},{"location":"api/types/#subagents_pydantic_ai.AgentMessage","title":"<code>subagents_pydantic_ai.AgentMessage</code>  <code>dataclass</code>","text":"<p>Message passed between agents via the message bus.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>MessageType</code> <p>The message type (task_assigned, question, etc.)</p> <code>sender</code> <code>str</code> <p>ID of the sending agent</p> <code>receiver</code> <code>str</code> <p>ID of the receiving agent</p> <code>payload</code> <code>Any</code> <p>Message-specific data</p> <code>task_id</code> <code>str</code> <p>Associated task ID for correlation</p> <code>id</code> <code>str</code> <p>Unique message identifier for tracing/debugging</p> <code>timestamp</code> <code>datetime</code> <p>When the message was created</p> <code>correlation_id</code> <code>str | None</code> <p>ID for request-response correlation</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>@dataclass\nclass AgentMessage:\n    \"\"\"Message passed between agents via the message bus.\n\n    Attributes:\n        type: The message type (task_assigned, question, etc.)\n        sender: ID of the sending agent\n        receiver: ID of the receiving agent\n        payload: Message-specific data\n        task_id: Associated task ID for correlation\n        id: Unique message identifier for tracing/debugging\n        timestamp: When the message was created\n        correlation_id: ID for request-response correlation\n    \"\"\"\n\n    type: MessageType\n    sender: str\n    receiver: str\n    payload: Any\n    task_id: str\n    id: str = field(default_factory=_generate_message_id)\n    timestamp: datetime = field(default_factory=datetime.now)\n    correlation_id: str | None = None\n</code></pre>"},{"location":"api/types/#messagetype","title":"MessageType","text":""},{"location":"api/types/#subagents_pydantic_ai.MessageType","title":"<code>subagents_pydantic_ai.MessageType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of messages that can be sent between agents.</p> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>class MessageType(str, Enum):\n    \"\"\"Types of messages that can be sent between agents.\"\"\"\n\n    TASK_ASSIGNED = \"task_assigned\"\n    \"\"\"A new task has been assigned to a subagent.\"\"\"\n\n    TASK_UPDATE = \"task_update\"\n    \"\"\"Progress update from a running task.\"\"\"\n\n    TASK_COMPLETED = \"task_completed\"\n    \"\"\"Task finished successfully.\"\"\"\n\n    TASK_FAILED = \"task_failed\"\n    \"\"\"Task failed with an error.\"\"\"\n\n    QUESTION = \"question\"\n    \"\"\"Subagent is asking the parent a question.\"\"\"\n\n    ANSWER = \"answer\"\n    \"\"\"Parent's response to a subagent question.\"\"\"\n\n    CANCEL_REQUEST = \"cancel_request\"\n    \"\"\"Request to cancel a task (soft cancel).\"\"\"\n\n    CANCEL_FORCED = \"cancel_forced\"\n    \"\"\"Immediate cancellation (hard cancel).\"\"\"\n</code></pre>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.TASK_ASSIGNED","title":"<code>TASK_ASSIGNED = 'task_assigned'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A new task has been assigned to a subagent.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.TASK_UPDATE","title":"<code>TASK_UPDATE = 'task_update'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Progress update from a running task.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.TASK_COMPLETED","title":"<code>TASK_COMPLETED = 'task_completed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task finished successfully.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.TASK_FAILED","title":"<code>TASK_FAILED = 'task_failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task failed with an error.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.QUESTION","title":"<code>QUESTION = 'question'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Subagent is asking the parent a question.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.ANSWER","title":"<code>ANSWER = 'answer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Parent's response to a subagent question.</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.CANCEL_REQUEST","title":"<code>CANCEL_REQUEST = 'cancel_request'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Request to cancel a task (soft cancel).</p>"},{"location":"api/types/#subagents_pydantic_ai.MessageType.CANCEL_FORCED","title":"<code>CANCEL_FORCED = 'cancel_forced'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Immediate cancellation (hard cancel).</p>"},{"location":"api/types/#toolsetfactory","title":"ToolsetFactory","text":""},{"location":"api/types/#subagents_pydantic_ai.ToolsetFactory","title":"<code>subagents_pydantic_ai.ToolsetFactory = Callable[[Any], list[Any]]</code>  <code>module-attribute</code>","text":"<p>Factory function that creates toolsets for a subagent.</p> <p>Takes deps as input and returns a list of toolsets to register.</p> Example Python<pre><code>def my_toolset_factory(deps: MyDeps) -&gt; list[Any]:\n    return [\n        create_file_toolset(deps.backend),\n        create_todo_toolset(),\n    ]\n</code></pre>"},{"location":"api/types/#decide_execution_mode","title":"decide_execution_mode","text":""},{"location":"api/types/#subagents_pydantic_ai.decide_execution_mode","title":"<code>subagents_pydantic_ai.decide_execution_mode(characteristics, config, force_mode=None)</code>","text":"<p>Decide whether to run sync or async based on task characteristics.</p> <p>This function implements the auto-mode selection logic. It considers: 1. Explicit force_mode override 2. Config-level preferred_mode 3. Task characteristics</p> <p>Parameters:</p> Name Type Description Default <code>characteristics</code> <code>TaskCharacteristics</code> <p>Task characteristics that influence the decision.</p> required <code>config</code> <code>SubAgentConfig</code> <p>Subagent configuration with optional preferences.</p> required <code>force_mode</code> <code>ExecutionMode | None</code> <p>Override mode (if specified and not \"auto\").</p> <code>None</code> <p>Returns:</p> Type Description <code>Literal['sync', 'async']</code> <p>The resolved execution mode: either \"sync\" or \"async\".</p> Example Python<pre><code>characteristics = TaskCharacteristics(\n    estimated_complexity=\"complex\",\n    can_run_independently=True,\n)\nconfig = SubAgentConfig(name=\"worker\", ...)\nmode = decide_execution_mode(characteristics, config)\n# mode will be \"async\" for complex independent tasks\n</code></pre> Source code in <code>src/subagents_pydantic_ai/types.py</code> Python<pre><code>def decide_execution_mode(\n    characteristics: TaskCharacteristics,\n    config: SubAgentConfig,\n    force_mode: ExecutionMode | None = None,\n) -&gt; Literal[\"sync\", \"async\"]:\n    \"\"\"Decide whether to run sync or async based on task characteristics.\n\n    This function implements the auto-mode selection logic. It considers:\n    1. Explicit force_mode override\n    2. Config-level preferred_mode\n    3. Task characteristics\n\n    Args:\n        characteristics: Task characteristics that influence the decision.\n        config: Subagent configuration with optional preferences.\n        force_mode: Override mode (if specified and not \"auto\").\n\n    Returns:\n        The resolved execution mode: either \"sync\" or \"async\".\n\n    Example:\n        ```python\n        characteristics = TaskCharacteristics(\n            estimated_complexity=\"complex\",\n            can_run_independently=True,\n        )\n        config = SubAgentConfig(name=\"worker\", ...)\n        mode = decide_execution_mode(characteristics, config)\n        # mode will be \"async\" for complex independent tasks\n        ```\n    \"\"\"\n    # Explicit override takes precedence\n    if force_mode and force_mode != \"auto\":\n        return force_mode\n\n    # Config-level preference\n    config_preference = config.get(\"preferred_mode\", \"auto\")\n    if config_preference != \"auto\":\n        return config_preference\n\n    # Always sync if needs user context or clarification likely\n    if characteristics.requires_user_context:\n        return \"sync\"\n    if characteristics.may_need_clarification and characteristics.is_time_sensitive:\n        return \"sync\"\n\n    # Prefer async for complex, independent tasks\n    if characteristics.estimated_complexity == \"complex\" and characteristics.can_run_independently:\n        return \"async\"\n\n    # Simple tasks - sync is fine\n    if characteristics.estimated_complexity == \"simple\":\n        return \"sync\"\n\n    # Default to async for moderate complexity if can run independently\n    if characteristics.can_run_independently:\n        return \"async\"\n\n    return \"sync\"\n</code></pre>"},{"location":"api/types/#usage-examples","title":"Usage Examples","text":""},{"location":"api/types/#creating-a-subagentconfig","title":"Creating a SubAgentConfig","text":"Python<pre><code>from subagents_pydantic_ai import SubAgentConfig\n\nconfig = SubAgentConfig(\n    name=\"researcher\",\n    description=\"Researches topics\",\n    instructions=\"You are a research assistant.\",\n    model=\"openai:gpt-4o\",\n    can_ask_questions=True,\n    max_questions=3,\n    preferred_mode=\"async\",\n    typical_complexity=\"complex\",\n)\n</code></pre>"},{"location":"api/types/#working-with-taskhandle","title":"Working with TaskHandle","text":"Python<pre><code>from subagents_pydantic_ai import TaskHandle, TaskStatus\n\n# TaskHandle is returned by async tasks\nhandle: TaskHandle = ...\n\n# Check status\nif handle.status == TaskStatus.COMPLETED:\n    print(f\"Result: {handle.result}\")\nelif handle.status == TaskStatus.WAITING_FOR_ANSWER:\n    print(f\"Question: {handle.pending_question}\")\nelif handle.status == TaskStatus.FAILED:\n    print(f\"Error: {handle.error}\")\n</code></pre>"},{"location":"api/types/#using-decide_execution_mode","title":"Using decide_execution_mode","text":"Python<pre><code>from subagents_pydantic_ai import (\n    decide_execution_mode,\n    TaskCharacteristics,\n    SubAgentConfig,\n)\n\ncharacteristics = TaskCharacteristics(\n    estimated_complexity=\"complex\",\n    requires_user_context=False,\n    can_run_independently=True,\n)\n\nconfig = SubAgentConfig(\n    name=\"worker\",\n    description=\"...\",\n    instructions=\"...\",\n)\n\nmode = decide_execution_mode(characteristics, config)\n# Returns \"async\" for complex, independent tasks\n</code></pre>"},{"location":"api/types/#message-types","title":"Message Types","text":"Python<pre><code>from subagents_pydantic_ai import MessageType, AgentMessage\n\n# Create a question message\nmessage = AgentMessage(\n    type=MessageType.QUESTION,\n    sender=\"subagent-123\",\n    receiver=\"parent-456\",\n    payload={\"question\": \"Which database?\"},\n    task_id=\"task-789\",\n)\n</code></pre>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This section covers the fundamental concepts you need to understand when working with Subagents for Pydantic AI.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>The library is built around three core concepts:</p> <ol> <li>Subagents - Specialized agents that handle specific tasks</li> <li>Toolset - The bridge that connects your parent agent to subagents</li> <li>Types - Data structures for configuration and communication</li> </ol>"},{"location":"concepts/#how-it-works","title":"How It Works","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Parent Agent                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502              Subagent Toolset                   \u2502    \u2502\n\u2502  \u2502  task() \u2502 check_task() \u2502 answer_subagent()      \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                         \u2502                               \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502         \u25bc               \u25bc               \u25bc               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502 researcher \u2502  \u2502   writer   \u2502  \u2502   coder    \u2502         \u2502\n\u2502  \u2502  (sync)    \u2502  \u2502  (async)   \u2502  \u2502  (auto)    \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502                                                         \u2502\n\u2502              Message Bus (pluggable)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>You define SubAgentConfigs with name, description, and instructions</li> <li>The toolset factory creates a toolset with delegation tools</li> <li>Your parent agent uses tools like <code>task()</code> to delegate work</li> <li>Subagents execute the work and return results</li> <li>The message bus handles communication (questions, answers, status)</li> </ol>"},{"location":"concepts/#in-this-section","title":"In This Section","text":"<ul> <li>Subagents - Configuring specialized agents</li> <li>Toolset - The delegation toolset</li> <li>Types - Data structures and enums</li> </ul>"},{"location":"concepts/subagents/","title":"Subagents","text":"<p>Subagents are specialized agents that handle specific types of tasks. Each subagent has its own system prompt, optional tools, and configuration.</p>"},{"location":"concepts/subagents/#subagentconfig","title":"SubAgentConfig","text":"<p>The <code>SubAgentConfig</code> TypedDict defines a subagent:</p> Python<pre><code>from subagents_pydantic_ai import SubAgentConfig\n\nsubagent = SubAgentConfig(\n    name=\"researcher\",\n    description=\"Researches topics and gathers information\",\n    instructions=\"You are a research assistant. Investigate thoroughly and provide sources.\",\n)\n</code></pre>"},{"location":"concepts/subagents/#required-fields","title":"Required Fields","text":"Field Type Description <code>name</code> <code>str</code> Unique identifier for the subagent <code>description</code> <code>str</code> Brief description shown to the parent agent <code>instructions</code> <code>str</code> System prompt for the subagent"},{"location":"concepts/subagents/#optional-fields","title":"Optional Fields","text":"Field Type Default Description <code>model</code> <code>str</code> Parent's model LLM model to use <code>can_ask_questions</code> <code>bool</code> <code>False</code> Enable <code>ask_parent</code> tool <code>max_questions</code> <code>int</code> <code>3</code> Max questions per task <code>preferred_mode</code> <code>str</code> <code>\"auto\"</code> <code>\"sync\"</code>, <code>\"async\"</code>, or <code>\"auto\"</code> <code>typical_complexity</code> <code>str</code> <code>\"moderate\"</code> <code>\"simple\"</code>, <code>\"moderate\"</code>, or <code>\"complex\"</code> <code>typically_needs_context</code> <code>bool</code> <code>False</code> Hint for auto-mode selection <code>toolsets</code> <code>list</code> <code>[]</code> Additional toolsets for the subagent <code>agent_kwargs</code> <code>dict</code> <code>{}</code> Extra kwargs for Agent constructor"},{"location":"concepts/subagents/#defining-subagents","title":"Defining Subagents","text":""},{"location":"concepts/subagents/#basic-definition","title":"Basic Definition","text":"Python<pre><code>subagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics and gathers information\",\n        instructions=\"You are a research assistant.\",\n    ),\n    SubAgentConfig(\n        name=\"writer\",\n        description=\"Writes content based on research\",\n        instructions=\"You are a technical writer.\",\n    ),\n]\n</code></pre>"},{"location":"concepts/subagents/#with-model-override","title":"With Model Override","text":"Python<pre><code>SubAgentConfig(\n    name=\"fast-helper\",\n    description=\"Quick helper for simple tasks\",\n    instructions=\"You help with simple tasks quickly.\",\n    model=\"openai:gpt-4o-mini\",  # Use a faster/cheaper model\n)\n</code></pre>"},{"location":"concepts/subagents/#with-questions-enabled","title":"With Questions Enabled","text":"Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    description=\"Analyzes data with clarifying questions\",\n    instructions=\"You analyze data. Ask questions when data is ambiguous.\",\n    can_ask_questions=True,\n    max_questions=5,\n)\n</code></pre>"},{"location":"concepts/subagents/#with-execution-mode-hints","title":"With Execution Mode Hints","text":"Python<pre><code>SubAgentConfig(\n    name=\"deep-researcher\",\n    description=\"Does thorough research that takes time\",\n    instructions=\"You do comprehensive research.\",\n    preferred_mode=\"async\",  # Suggest async execution\n    typical_complexity=\"complex\",  # Hint for auto-mode\n)\n</code></pre>"},{"location":"concepts/subagents/#with-additional-tools","title":"With Additional Tools","text":"Python<pre><code>from pydantic_ai_backends import create_console_toolset\n\nSubAgentConfig(\n    name=\"coder\",\n    description=\"Writes and tests code\",\n    instructions=\"You write Python code.\",\n    toolsets=[create_console_toolset()],  # Give file access\n)\n</code></pre>"},{"location":"concepts/subagents/#with-built-in-tools","title":"With Built-in Tools","text":"Python<pre><code>from pydantic_ai.builtin_tools import WebSearchTool\n\nSubAgentConfig(\n    name=\"web-researcher\",\n    description=\"Researches using web search\",\n    instructions=\"You research topics using web search.\",\n    agent_kwargs={\"builtin_tools\": [WebSearchTool()]},\n)\n</code></pre>"},{"location":"concepts/subagents/#subagent-descriptions","title":"Subagent Descriptions","text":"<p>The <code>description</code> field is crucial - it tells the parent agent when to use each subagent:</p> Python<pre><code># Good descriptions - clear about capabilities\nSubAgentConfig(\n    name=\"sql-expert\",\n    description=\"Writes and optimizes SQL queries for PostgreSQL databases\",\n    ...\n)\n\nSubAgentConfig(\n    name=\"code-reviewer\",\n    description=\"Reviews Python code for bugs, security issues, and style\",\n    ...\n)\n\n# Bad descriptions - too vague\nSubAgentConfig(\n    name=\"helper\",\n    description=\"Helps with stuff\",  # Too vague!\n    ...\n)\n</code></pre>"},{"location":"concepts/subagents/#subagent-instructions","title":"Subagent Instructions","text":"<p>Write clear, focused instructions:</p> Python<pre><code>SubAgentConfig(\n    name=\"code-reviewer\",\n    description=\"Reviews code for quality issues\",\n    instructions=\"\"\"You are an expert code reviewer.\n\nWhen reviewing code:\n1. Look for bugs and logic errors\n2. Check for security vulnerabilities\n3. Assess code style and readability\n4. Suggest improvements with examples\n\nFormat your response as:\n## Summary\n[Brief assessment]\n\n## Issues Found\n[List of issues with severity]\n\n## Recommendations\n[Actionable suggestions]\n\"\"\",\n)\n</code></pre>"},{"location":"concepts/subagents/#best-practices","title":"Best Practices","text":""},{"location":"concepts/subagents/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each subagent should do one thing well:</p> Python<pre><code># Good - focused\nSubAgentConfig(name=\"test-writer\", description=\"Generates pytest tests\", ...)\nSubAgentConfig(name=\"doc-writer\", description=\"Writes documentation\", ...)\n\n# Bad - too broad\nSubAgentConfig(name=\"developer\", description=\"Does all development tasks\", ...)\n</code></pre>"},{"location":"concepts/subagents/#2-clear-naming","title":"2. Clear Naming","text":"<p>Use descriptive, hyphenated names:</p> Python<pre><code># Good\n\"code-reviewer\", \"sql-expert\", \"test-writer\"\n\n# Bad\n\"cr\", \"agent1\", \"myAgent\"\n</code></pre>"},{"location":"concepts/subagents/#3-appropriate-tools","title":"3. Appropriate Tools","text":"<p>Only give subagents the tools they need:</p> Python<pre><code># Researcher doesn't need file write access\nSubAgentConfig(\n    name=\"researcher\",\n    description=\"Researches topics\",\n    instructions=\"...\",\n    # No toolsets needed\n)\n\n# Coder needs file access\nSubAgentConfig(\n    name=\"coder\",\n    description=\"Writes code\",\n    instructions=\"...\",\n    toolsets=[create_console_toolset()],\n)\n</code></pre>"},{"location":"concepts/subagents/#next-steps","title":"Next Steps","text":"<ul> <li>Toolset - Learn about the delegation toolset</li> <li>Execution Modes - Sync vs async execution</li> <li>Questions - Parent-child communication</li> </ul>"},{"location":"concepts/toolset/","title":"Toolset","text":"<p>The <code>create_subagent_toolset()</code> function creates a toolset that adds delegation capabilities to your Pydantic AI agent.</p>"},{"location":"concepts/toolset/#creating-a-toolset","title":"Creating a Toolset","text":"Python<pre><code>from subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics\",\n        instructions=\"You are a research assistant.\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n</code></pre>"},{"location":"concepts/toolset/#factory-parameters","title":"Factory Parameters","text":"Parameter Type Default Description <code>subagents</code> <code>list[SubAgentConfig]</code> <code>[]</code> List of subagent configurations <code>default_model</code> <code>str \\| None</code> <code>None</code> Default model for subagents <code>toolsets_factory</code> <code>Callable</code> <code>None</code> Factory to create toolsets for subagents <code>max_nesting_depth</code> <code>int</code> <code>2</code> Maximum subagent nesting depth <code>general_purpose_config</code> <code>SubAgentConfig \\| None</code> Auto Config for the \"general\" subagent <code>descriptions</code> <code>dict[str, str] \\| None</code> <code>None</code> Override default tool descriptions by tool name"},{"location":"concepts/toolset/#adding-to-an-agent","title":"Adding to an Agent","text":"Python<pre><code>from pydantic_ai import Agent\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"You can delegate tasks to specialized subagents.\",\n)\n</code></pre>"},{"location":"concepts/toolset/#available-tools","title":"Available Tools","text":"<p>The toolset provides these tools to your agent:</p>"},{"location":"concepts/toolset/#task","title":"task","text":"<p>Delegate a task to a subagent.</p> Python<pre><code># The agent calls:\ntask(\n    description=\"Research Python async patterns\",\n    subagent_type=\"researcher\",\n    mode=\"sync\",  # or \"async\" or \"auto\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>description</code> <code>str</code> What the subagent should do <code>subagent_type</code> <code>str</code> Name of the subagent to use <code>mode</code> <code>str</code> <code>\"sync\"</code>, <code>\"async\"</code>, or <code>\"auto\"</code>"},{"location":"concepts/toolset/#check_task","title":"check_task","text":"<p>Check the status of a background task.</p> Python<pre><code># The agent calls:\ncheck_task(task_id=\"abc123\")\n</code></pre> <p>Returns: Status, result (if complete), or pending question (if waiting).</p>"},{"location":"concepts/toolset/#answer_subagent","title":"answer_subagent","text":"<p>Answer a question from a blocked subagent.</p> Python<pre><code># The agent calls:\nanswer_subagent(task_id=\"abc123\", answer=\"Use PostgreSQL for this project\")\n</code></pre>"},{"location":"concepts/toolset/#list_active_tasks","title":"list_active_tasks","text":"<p>List all running background tasks.</p> Python<pre><code># The agent calls:\nlist_active_tasks()\n</code></pre> <p>Returns: List of task IDs, subagent names, and statuses.</p>"},{"location":"concepts/toolset/#soft_cancel_task","title":"soft_cancel_task","text":"<p>Request cooperative cancellation.</p> Python<pre><code># The agent calls:\nsoft_cancel_task(task_id=\"abc123\")\n</code></pre> <p>The subagent will receive a cancellation request and should stop gracefully.</p>"},{"location":"concepts/toolset/#hard_cancel_task","title":"hard_cancel_task","text":"<p>Immediately cancel a task.</p> Python<pre><code># The agent calls:\nhard_cancel_task(task_id=\"abc123\")\n</code></pre> <p>Forces immediate termination.</p>"},{"location":"concepts/toolset/#toolsets-factory","title":"Toolsets Factory","text":"<p>Provide tools to your subagents:</p> Python<pre><code>from pydantic_ai_backends import create_console_toolset\n\ndef my_toolsets_factory(deps):\n    \"\"\"Create toolsets for each subagent.\"\"\"\n    return [\n        create_console_toolset(),  # File operations\n    ]\n\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    toolsets_factory=my_toolsets_factory,\n)\n</code></pre> <p>The factory is called for each subagent with cloned dependencies.</p>"},{"location":"concepts/toolset/#nesting-depth","title":"Nesting Depth","text":"<p>Control how deep subagents can nest:</p> Python<pre><code># Allow subagents to have their own subagents (2 levels deep)\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    max_nesting_depth=2,\n)\n\n# No nesting - subagents can't delegate\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    max_nesting_depth=0,\n)\n</code></pre>"},{"location":"concepts/toolset/#general-purpose-subagent","title":"General Purpose Subagent","text":"<p>By default, a \"general\" subagent is added for tasks that don't match specific subagents:</p> Python<pre><code># Customize the general subagent\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    general_purpose_config=SubAgentConfig(\n        name=\"general\",\n        description=\"Handles miscellaneous tasks\",\n        instructions=\"You are a general-purpose assistant.\",\n    ),\n)\n\n# Disable the general subagent\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    general_purpose_config=None,\n)\n</code></pre>"},{"location":"concepts/toolset/#custom-tool-descriptions","title":"Custom Tool Descriptions","text":"<p>Override the default tool descriptions to better guide LLM behavior. This is useful when you want descriptions that are more specific to your use case:</p> Python<pre><code>toolset = create_subagent_toolset(\n    subagents=subagents,\n    descriptions={\n        \"task\": \"Assign a task to a specialized subagent\",\n        \"check_task\": \"Check the status of a delegated task\",\n        \"list_active_tasks\": \"Show all currently running background tasks\",\n    },\n)\n</code></pre> <p>Only the tool names you include in the dictionary are overridden; the rest keep their built-in defaults. Available tool names:</p> Tool Name Description <code>task</code> Delegate a task to a subagent <code>check_task</code> Check status of a background task <code>answer_subagent</code> Answer a question from a blocked subagent <code>list_active_tasks</code> List all running background tasks <code>wait_tasks</code> Wait for background tasks to complete <code>soft_cancel_task</code> Request cooperative cancellation <code>hard_cancel_task</code> Immediately cancel a task"},{"location":"concepts/toolset/#system-prompt","title":"System Prompt","text":"<p>Add context about available subagents to your agent's system prompt:</p> Python<pre><code>from subagents_pydantic_ai import get_subagent_system_prompt\n\n# Generate prompt listing available subagents\nprompt = get_subagent_system_prompt(deps, compiled_subagents)\n</code></pre> <p>This generates text like:</p> Text Only<pre><code>## Available Subagents\n\nYou can delegate tasks to these specialized subagents:\n\n- **researcher**: Researches topics and gathers information\n- **writer**: Writes content based on research\n- **coder**: Writes and tests Python code\n\nUse the `task` tool to delegate work.\n</code></pre>"},{"location":"concepts/toolset/#next-steps","title":"Next Steps","text":"<ul> <li>Types - Data structures and enums</li> <li>Execution Modes - Sync vs async</li> <li>Examples - Working examples</li> </ul>"},{"location":"concepts/types/","title":"Types","text":"<p>This page documents the key data structures used in Subagents for Pydantic AI.</p>"},{"location":"concepts/types/#configuration-types","title":"Configuration Types","text":""},{"location":"concepts/types/#subagentconfig","title":"SubAgentConfig","text":"<p>Configuration for defining a subagent.</p> Python<pre><code>from subagents_pydantic_ai import SubAgentConfig\n\nconfig = SubAgentConfig(\n    name=\"researcher\",\n    description=\"Researches topics\",\n    instructions=\"You are a research assistant.\",\n    model=\"openai:gpt-4o\",  # optional\n    can_ask_questions=True,  # optional\n    max_questions=5,  # optional\n)\n</code></pre> <p>See Subagents for full documentation.</p>"},{"location":"concepts/types/#compiledsubagent","title":"CompiledSubAgent","text":"<p>A pre-compiled subagent ready for use. Created internally by the toolset.</p> Python<pre><code>from subagents_pydantic_ai import CompiledSubAgent\n\n@dataclass\nclass CompiledSubAgent:\n    name: str               # Unique identifier\n    description: str        # Brief description\n    config: SubAgentConfig  # Original configuration\n    agent: object | None    # Agent instance\n</code></pre>"},{"location":"concepts/types/#execution-types","title":"Execution Types","text":""},{"location":"concepts/types/#executionmode","title":"ExecutionMode","text":"<p>How a task should be executed.</p> Python<pre><code>from subagents_pydantic_ai import ExecutionMode\n\n# Type alias\nExecutionMode = Literal[\"sync\", \"async\", \"auto\"]\n</code></pre> Mode Description <code>sync</code> Block until complete <code>async</code> Run in background <code>auto</code> Automatically decide"},{"location":"concepts/types/#taskstatus","title":"TaskStatus","text":"<p>Status of a background task.</p> Python<pre><code>from subagents_pydantic_ai import TaskStatus\n\nclass TaskStatus(str, Enum):\n    PENDING = \"pending\"           # Queued but not started\n    RUNNING = \"running\"           # Currently executing\n    WAITING_FOR_ANSWER = \"waiting_for_answer\"  # Blocked on question\n    COMPLETED = \"completed\"       # Finished successfully\n    FAILED = \"failed\"             # Failed with error\n    CANCELLED = \"cancelled\"       # Was cancelled\n</code></pre>"},{"location":"concepts/types/#taskpriority","title":"TaskPriority","text":"<p>Priority levels for background tasks.</p> Python<pre><code>from subagents_pydantic_ai import TaskPriority\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    NORMAL = \"normal\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n</code></pre>"},{"location":"concepts/types/#taskhandle","title":"TaskHandle","text":"<p>Handle for managing a background task.</p> Python<pre><code>from subagents_pydantic_ai import TaskHandle\n\n@dataclass\nclass TaskHandle:\n    task_id: str              # Unique identifier\n    subagent_name: str        # Name of executing subagent\n    description: str          # Task description\n    status: TaskStatus        # Current status\n    priority: TaskPriority    # Task priority\n    created_at: datetime      # When created\n    started_at: datetime | None   # When started\n    completed_at: datetime | None # When finished\n    result: str | None        # Result (if completed)\n    error: str | None         # Error (if failed)\n    pending_question: str | None  # Question waiting for answer\n</code></pre>"},{"location":"concepts/types/#taskcharacteristics","title":"TaskCharacteristics","text":"<p>Characteristics used for auto-mode selection.</p> Python<pre><code>from subagents_pydantic_ai import TaskCharacteristics\n\n@dataclass\nclass TaskCharacteristics:\n    estimated_complexity: Literal[\"simple\", \"moderate\", \"complex\"] = \"moderate\"\n    requires_user_context: bool = False\n    is_time_sensitive: bool = False\n    can_run_independently: bool = True\n    may_need_clarification: bool = False\n</code></pre>"},{"location":"concepts/types/#message-types","title":"Message Types","text":""},{"location":"concepts/types/#messagetype","title":"MessageType","text":"<p>Types of messages between agents.</p> Python<pre><code>from subagents_pydantic_ai import MessageType\n\nclass MessageType(str, Enum):\n    TASK_ASSIGNED = \"task_assigned\"\n    TASK_UPDATE = \"task_update\"\n    TASK_COMPLETED = \"task_completed\"\n    TASK_FAILED = \"task_failed\"\n    QUESTION = \"question\"\n    ANSWER = \"answer\"\n    CANCEL_REQUEST = \"cancel_request\"\n    CANCEL_FORCED = \"cancel_forced\"\n</code></pre>"},{"location":"concepts/types/#agentmessage","title":"AgentMessage","text":"<p>Message passed between agents via the message bus.</p> Python<pre><code>from subagents_pydantic_ai import AgentMessage\n\n@dataclass\nclass AgentMessage:\n    type: MessageType       # Message type\n    sender: str             # Sender agent ID\n    receiver: str           # Receiver agent ID\n    payload: Any            # Message data\n    task_id: str            # Associated task\n    id: str                 # Unique message ID\n    timestamp: datetime     # When created\n    correlation_id: str | None  # For request-response\n</code></pre>"},{"location":"concepts/types/#protocol-types","title":"Protocol Types","text":""},{"location":"concepts/types/#subagentdepsprotocol","title":"SubAgentDepsProtocol","text":"<p>Protocol that your dependencies must implement.</p> Python<pre><code>from subagents_pydantic_ai import SubAgentDepsProtocol\n\nclass SubAgentDepsProtocol(Protocol):\n    subagents: dict[str, Any]\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; Self:\n        \"\"\"Create a copy of deps for a subagent.\"\"\"\n        ...\n</code></pre> <p>Example implementation:</p> Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy()\n        )\n</code></pre>"},{"location":"concepts/types/#messagebusprotocol","title":"MessageBusProtocol","text":"<p>Protocol for custom message bus implementations.</p> Python<pre><code>from subagents_pydantic_ai import MessageBusProtocol\n\nclass MessageBusProtocol(Protocol):\n    async def send(self, message: AgentMessage) -&gt; None: ...\n    async def receive(self, agent_id: str, timeout: float | None = None) -&gt; AgentMessage | None: ...\n    async def subscribe(self, agent_id: str) -&gt; None: ...\n    async def unsubscribe(self, agent_id: str) -&gt; None: ...\n</code></pre>"},{"location":"concepts/types/#utility-functions","title":"Utility Functions","text":""},{"location":"concepts/types/#decide_execution_mode","title":"decide_execution_mode","text":"<p>Decide between sync and async based on characteristics.</p> Python<pre><code>from subagents_pydantic_ai import decide_execution_mode, TaskCharacteristics\n\ncharacteristics = TaskCharacteristics(\n    estimated_complexity=\"complex\",\n    can_run_independently=True,\n)\n\nmode = decide_execution_mode(\n    characteristics=characteristics,\n    config=my_subagent_config,\n    force_mode=None,  # or \"sync\"/\"async\" to override\n)\n# Returns \"async\" for complex independent tasks\n</code></pre>"},{"location":"concepts/types/#type-exports","title":"Type Exports","text":"<p>All types are exported from the main module:</p> Python<pre><code>from subagents_pydantic_ai import (\n    # Configuration\n    SubAgentConfig,\n    CompiledSubAgent,\n    # Execution\n    ExecutionMode,\n    TaskStatus,\n    TaskPriority,\n    TaskHandle,\n    TaskCharacteristics,\n    # Messages\n    MessageType,\n    AgentMessage,\n    # Protocols\n    SubAgentDepsProtocol,\n    MessageBusProtocol,\n    # Functions\n    decide_execution_mode,\n)\n</code></pre>"},{"location":"concepts/types/#next-steps","title":"Next Steps","text":"<ul> <li>Execution Modes - Learn about sync vs async</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples showing how to use Subagents for Pydantic AI.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li>Basic Usage - Your first subagent delegation</li> <li>Sync vs Async - Understanding execution modes</li> </ul>"},{"location":"examples/#agent-features","title":"Agent Features","text":"<ul> <li>Giving Subagents Tools - Provide capabilities to subagents</li> <li>Questions - Parent-child communication</li> <li>Nesting - Subagents with their own subagents</li> </ul>"},{"location":"examples/#applications","title":"Applications","text":"<ul> <li>Research Team - Multi-agent research workflow</li> </ul>"},{"location":"examples/basic-usage/","title":"Basic Usage","text":"<p>This example shows how to add subagent delegation to a Pydantic AI agent.</p>"},{"location":"examples/basic-usage/#complete-example","title":"Complete Example","text":"Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n# Step 1: Create dependencies that implement SubAgentDepsProtocol\n@dataclass\nclass Deps:\n    \"\"\"Dependencies for our agent.\"\"\"\n\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        \"\"\"Create a copy for subagents.\"\"\"\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\n# Step 2: Define specialized subagents\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches topics and gathers information\",\n        instructions=\"\"\"You are a research assistant.\n\nWhen given a research task:\n1. Break down the topic into key questions\n2. Provide factual, well-organized information\n3. Include relevant examples\n4. Cite sources when possible\n\"\"\",\n    ),\n    SubAgentConfig(\n        name=\"summarizer\",\n        description=\"Summarizes long content into concise points\",\n        instructions=\"\"\"You are a summarization expert.\n\nWhen summarizing:\n1. Identify the main points\n2. Remove redundancy\n3. Keep essential details\n4. Use bullet points for clarity\n\"\"\",\n    ),\n]\n\n# Step 3: Create the toolset\ntoolset = create_subagent_toolset(subagents=subagents)\n\n# Step 4: Create the parent agent with the toolset\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You are a helpful assistant that can delegate tasks\nto specialized subagents.\n\nAvailable subagents:\n- researcher: For research tasks\n- summarizer: For summarizing content\n\nUse the task() tool to delegate work to the appropriate subagent.\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # The agent will delegate to the researcher subagent\n    result = await agent.run(\n        \"Research the benefits of async programming in Python\",\n        deps=deps,\n    )\n\n    print(\"Result:\")\n    print(result.output)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic-usage/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":""},{"location":"examples/basic-usage/#1-dependencies","title":"1. Dependencies","text":"<p>Your dependencies must implement <code>SubAgentDepsProtocol</code>:</p> Python<pre><code>@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n</code></pre> <p>The <code>clone_for_subagent</code> method creates isolated dependencies for each subagent.</p>"},{"location":"examples/basic-usage/#2-subagent-configuration","title":"2. Subagent Configuration","text":"<p>Define what each subagent does:</p> Python<pre><code>SubAgentConfig(\n    name=\"researcher\",  # Unique identifier\n    description=\"Researches topics\",  # Shown to parent\n    instructions=\"You are a research assistant...\",  # System prompt\n)\n</code></pre>"},{"location":"examples/basic-usage/#3-toolset-creation","title":"3. Toolset Creation","text":"<p>Create the toolset that adds delegation tools:</p> Python<pre><code>toolset = create_subagent_toolset(subagents=subagents)\n</code></pre>"},{"location":"examples/basic-usage/#4-agent-integration","title":"4. Agent Integration","text":"<p>Add the toolset to your agent:</p> Python<pre><code>agent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n)\n</code></pre>"},{"location":"examples/basic-usage/#what-happens-at-runtime","title":"What Happens at Runtime","text":"<ol> <li>User asks: \"Research the benefits of async programming\"</li> <li>Parent agent decides to delegate to \"researcher\"</li> <li>Parent calls: <code>task(description=\"...\", subagent_type=\"researcher\")</code></li> <li>Researcher subagent executes the task</li> <li>Result is returned to parent</li> <li>Parent formats and returns final response</li> </ol>"},{"location":"examples/basic-usage/#running-the-example","title":"Running the Example","text":"Bash<pre><code># Set your API key\nexport OPENAI_API_KEY=your-key\n\n# Run the script\npython basic_usage.py\n</code></pre>"},{"location":"examples/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Sync vs Async - Learn about execution modes</li> <li>Giving Subagents Tools - Provide capabilities to subagents</li> </ul>"},{"location":"examples/nesting/","title":"Nested Subagents","text":"<p>This example shows how subagents can have their own subagents.</p>"},{"location":"examples/nesting/#overview","title":"Overview","text":"<p>Subagents can delegate to other subagents, creating hierarchical workflows:</p> Text Only<pre><code>Parent Agent\n    \u2514\u2500\u2500 Manager Subagent\n            \u251c\u2500\u2500 Researcher Subagent\n            \u2514\u2500\u2500 Writer Subagent\n</code></pre>"},{"location":"examples/nesting/#basic-nesting","title":"Basic Nesting","text":"Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        # Important: Reduce depth for nested subagents\n        return Deps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n        )\n\n\n# Level 2: Leaf subagents (no further delegation)\nleaf_subagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches specific topics\",\n        instructions=\"You research topics and provide facts.\",\n    ),\n    SubAgentConfig(\n        name=\"writer\",\n        description=\"Writes content\",\n        instructions=\"You write clear, engaging content.\",\n    ),\n]\n\n# Level 1: Manager that delegates to leaf subagents\nmanager_subagents = [\n    SubAgentConfig(\n        name=\"content-manager\",\n        description=\"Manages content creation by delegating to specialists\",\n        instructions=\"\"\"You manage content creation.\n\nYou have access to these specialists:\n- researcher: Researches topics\n- writer: Writes content\n\nWorkflow:\n1. Delegate research to researcher\n2. Delegate writing to writer\n3. Review and compile results\n\"\"\",\n    ),\n]\n\n\ndef create_manager_toolsets(deps: Deps) -&gt; list:\n    \"\"\"Create toolsets for the manager, including nested delegation.\"\"\"\n    return [\n        create_subagent_toolset(\n            subagents=leaf_subagents,\n            max_nesting_depth=0,  # Leaf subagents can't delegate further\n        ),\n    ]\n\n\n# Top-level toolset\ntoolset = create_subagent_toolset(\n    subagents=manager_subagents,\n    toolsets_factory=create_manager_toolsets,\n    max_nesting_depth=1,  # Allow one level of nesting\n)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"You can delegate complex content tasks to the content-manager.\",\n)\n\n\nasync def main():\n    result = await agent.run(\n        \"Create a blog post about machine learning\",\n        deps=Deps(),\n    )\n\n    print(result.output)\n    # The content-manager delegated to researcher, then to writer\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/nesting/#controlling-nesting-depth","title":"Controlling Nesting Depth","text":"<p>Use <code>max_nesting_depth</code> to limit how deep delegation can go:</p> Python<pre><code># No nesting (depth=0)\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    max_nesting_depth=0,  # Subagents cannot delegate\n)\n\n# One level (depth=1)\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    max_nesting_depth=1,  # Subagents can delegate to leaf agents\n)\n\n# Two levels (depth=2)\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    max_nesting_depth=2,  # Subagents can delegate to agents that can delegate\n)\n</code></pre>"},{"location":"examples/nesting/#hierarchical-team-structure","title":"Hierarchical Team Structure","text":"Python<pre><code># Executive level\nexecutive = SubAgentConfig(\n    name=\"product-lead\",\n    description=\"Leads product development\",\n    instructions=\"\"\"You lead product development.\n\nDelegate to:\n- engineering-manager: For technical work\n- design-manager: For design work\n\"\"\",\n)\n\n# Manager level\nmanagers = [\n    SubAgentConfig(\n        name=\"engineering-manager\",\n        description=\"Manages engineering tasks\",\n        instructions=\"\"\"You manage engineering.\n\nDelegate to:\n- backend-dev: Backend development\n- frontend-dev: Frontend development\n\"\"\",\n    ),\n    SubAgentConfig(\n        name=\"design-manager\",\n        description=\"Manages design tasks\",\n        instructions=\"You manage design work.\",\n    ),\n]\n\n# Individual contributor level\nics = [\n    SubAgentConfig(\n        name=\"backend-dev\",\n        description=\"Backend developer\",\n        instructions=\"You write backend code.\",\n    ),\n    SubAgentConfig(\n        name=\"frontend-dev\",\n        description=\"Frontend developer\",\n        instructions=\"You write frontend code.\",\n    ),\n]\n\n\ndef create_manager_toolsets(deps):\n    return [create_subagent_toolset(subagents=ics, max_nesting_depth=0)]\n\n\ndef create_executive_toolsets(deps):\n    return [\n        create_subagent_toolset(\n            subagents=managers,\n            toolsets_factory=create_manager_toolsets,\n            max_nesting_depth=1,\n        )\n    ]\n\n\ntoolset = create_subagent_toolset(\n    subagents=[executive],\n    toolsets_factory=create_executive_toolsets,\n    max_nesting_depth=2,\n)\n</code></pre>"},{"location":"examples/nesting/#clone-for-subagent","title":"Clone for Subagent","text":"<p>The <code>clone_for_subagent</code> method is crucial for nesting:</p> Python<pre><code>@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n    shared_state: dict = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        \"\"\"Create isolated deps for subagent.\n\n        Args:\n            max_depth: How many more levels of nesting to allow.\n                       0 = this subagent cannot delegate further.\n        \"\"\"\n        return Deps(\n            # Clear subagents if no more nesting allowed\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n            # Share read-only state\n            shared_state=self.shared_state,\n        )\n</code></pre>"},{"location":"examples/nesting/#best-practices","title":"Best Practices","text":""},{"location":"examples/nesting/#1-limit-depth","title":"1. Limit Depth","text":"<p>Don't nest too deeply. 2-3 levels is usually enough:</p> Python<pre><code># Good: Clear hierarchy\nParent \u2192 Manager \u2192 Worker\n\n# Avoid: Too deep\nParent \u2192 Director \u2192 Manager \u2192 Lead \u2192 Worker \u2192 Helper\n</code></pre>"},{"location":"examples/nesting/#2-clear-responsibilities","title":"2. Clear Responsibilities","text":"<p>Each level should have distinct responsibilities:</p> Python<pre><code># Good: Clear separation\n\"project-manager\": Coordinates overall project\n\"tech-lead\": Makes technical decisions\n\"developer\": Writes code\n\n# Avoid: Overlapping roles\n\"helper1\": Does stuff\n\"helper2\": Also does stuff\n</code></pre>"},{"location":"examples/nesting/#3-avoid-circular-delegation","title":"3. Avoid Circular Delegation","text":"<p>Ensure subagents don't create delegation loops:</p> Python<pre><code># Bad: A delegates to B, B delegates to A\nSubAgentConfig(name=\"A\", instructions=\"Delegate to B\")\nSubAgentConfig(name=\"B\", instructions=\"Delegate to A\")\n\n# Good: Clear hierarchy with termination\nSubAgentConfig(name=\"manager\", instructions=\"Delegate to workers\")\nSubAgentConfig(name=\"worker\", instructions=\"Complete the task directly\")\n</code></pre>"},{"location":"examples/nesting/#next-steps","title":"Next Steps","text":"<ul> <li>Research Team - Multi-agent workflow example</li> </ul>"},{"location":"examples/questions/","title":"Questions Example","text":"<p>This example demonstrates parent-child Q&amp;A communication.</p>"},{"location":"examples/questions/#basic-questions","title":"Basic Questions","text":"Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"data-analyst\",\n        description=\"Analyzes data with clarifying questions\",\n        instructions=\"\"\"You are a data analyst.\n\nWhen analyzing data, ask clarifying questions if:\n- The time period is unclear\n- Metrics are ambiguous\n- Comparison baselines aren't specified\n\nUse ask_parent() to ask questions.\nWait for the answer before proceeding.\n\"\"\",\n        can_ask_questions=True,\n        max_questions=3,\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You manage data analysis tasks.\n\nWhen the data-analyst asks a question:\n1. You'll see the question in the task status\n2. Use answer_subagent(task_id, answer) to respond\n3. The analyst will continue with your answer\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # Start analysis - analyst may ask questions\n    result = await agent.run(\n        \"Analyze our sales data\",\n        deps=deps,\n    )\n\n    print(result.output)\n    # If analyst asked \"Which quarter should I analyze?\",\n    # parent answered \"Q4 2024\",\n    # then analyst completed the analysis\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/questions/#async-questions","title":"Async Questions","text":"<p>With async mode, questions put the task in WAITING_FOR_ANSWER state:</p> Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"planner\",\n        description=\"Creates project plans with clarification\",\n        instructions=\"\"\"You create detailed project plans.\n\nBefore creating a plan, clarify:\n- Project scope and constraints\n- Key stakeholders\n- Timeline expectations\n\nAsk questions using ask_parent().\n\"\"\",\n        can_ask_questions=True,\n        max_questions=5,\n        preferred_mode=\"async\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You manage project planning.\n\nWorkflow:\n1. Start planning task (async)\n2. Check task status periodically\n3. If status is WAITING_FOR_ANSWER, answer the question\n4. Continue until planning is complete\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # Conversation 1: Start the task\n    result1 = await agent.run(\n        \"Create a plan for building a mobile app\",\n        deps=deps,\n    )\n    print(\"Response 1:\", result1.output)\n    # \"Started planning task. Task ID: plan-123\"\n\n    # Conversation 2: Check and answer\n    result2 = await agent.run(\n        \"Check on the planning task\",\n        deps=deps,\n        message_history=result1.all_messages(),\n    )\n    print(\"Response 2:\", result2.output)\n    # \"The planner asks: What's the target platform (iOS, Android, or both)?\n    #  I'll answer: Both platforms.\"\n\n    # Conversation 3: Get final result\n    result3 = await agent.run(\n        \"Check if planning is done\",\n        deps=deps,\n        message_history=result2.all_messages(),\n    )\n    print(\"Response 3:\", result3.output)\n    # \"Planning complete! Here's the project plan...\"\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/questions/#multiple-questions","title":"Multiple Questions","text":"<p>Handle a sequence of questions:</p> Python<pre><code>SubAgentConfig(\n    name=\"requirements-analyst\",\n    description=\"Gathers requirements through questions\",\n    instructions=\"\"\"You gather software requirements.\n\nProcess:\n1. Ask about the problem being solved\n2. Ask about target users\n3. Ask about key features\n4. Ask about constraints\n5. Compile requirements document\n\nAsk one question at a time.\nWait for each answer before asking the next.\n\"\"\",\n    can_ask_questions=True,\n    max_questions=10,\n)\n</code></pre>"},{"location":"examples/questions/#question-guidelines","title":"Question Guidelines","text":"<p>Help subagents ask good questions:</p> Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    instructions=\"\"\"\n## Asking Questions\n\nWhen you need clarification:\n\n1. Be specific\n   \u274c \"What should I do?\"\n   \u2705 \"Should I include Q4 data in the analysis?\"\n\n2. Provide context\n   \u274c \"Which one?\"\n   \u2705 \"I found 3 CSV files. Which should I use: sales_2023.csv, sales_2024.csv, or sales_all.csv?\"\n\n3. Offer options when possible\n   \u274c \"What format?\"\n   \u2705 \"Should I output as: (a) JSON, (b) Markdown, or (c) CSV?\"\n\n4. Ask one thing at a time\n   \u274c \"What time period, which metrics, and what format?\"\n   \u2705 \"What time period should I analyze?\"\n\"\"\",\n    can_ask_questions=True,\n)\n</code></pre>"},{"location":"examples/questions/#handling-no-answer","title":"Handling No Answer","text":"<p>What if the parent doesn't answer?</p> Python<pre><code>SubAgentConfig(\n    name=\"analyst\",\n    instructions=\"\"\"\n## If No Answer\n\nIf you've asked a question and received no answer:\n1. Wait a reasonable time\n2. Proceed with the most sensible default\n3. Clearly document your assumption\n4. Note that results may need revision\n\nExample:\n\"Note: No answer received for time period question.\nDefaulting to full year 2024. Results can be re-run\nfor a different period if needed.\"\n\"\"\",\n    can_ask_questions=True,\n)\n</code></pre>"},{"location":"examples/questions/#next-steps","title":"Next Steps","text":"<ul> <li>Nesting - Subagents with their own subagents</li> <li>Research Team - Multi-agent workflow</li> </ul>"},{"location":"examples/research-team/","title":"Research Team Example","text":"<p>This example demonstrates a multi-agent research workflow with parallel execution.</p>"},{"location":"examples/research-team/#overview","title":"Overview","text":"<p>A research coordinator manages a team of specialists:</p> <ul> <li>Researcher: Gathers information on topics</li> <li>Analyst: Analyzes and synthesizes findings</li> <li>Writer: Produces the final report</li> </ul>"},{"location":"examples/research-team/#complete-example","title":"Complete Example","text":"Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n    research_notes: list[str] = field(default_factory=list)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n            research_notes=self.research_notes,  # Share notes\n        )\n\n\n# Define the research team\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches specific topics and gathers facts\",\n        instructions=\"\"\"You are a thorough researcher.\n\nWhen researching a topic:\n1. Identify key aspects to investigate\n2. Gather factual information\n3. Note sources and credibility\n4. Organize findings clearly\n\nOutput format:\n## Topic: [topic name]\n\n### Key Findings\n- [finding 1]\n- [finding 2]\n\n### Sources\n- [source 1]\n- [source 2]\n\"\"\",\n        preferred_mode=\"async\",  # Research can take time\n        typical_complexity=\"complex\",\n    ),\n    SubAgentConfig(\n        name=\"analyst\",\n        description=\"Analyzes research findings and identifies patterns\",\n        instructions=\"\"\"You are a critical analyst.\n\nWhen analyzing findings:\n1. Identify patterns and trends\n2. Note contradictions or gaps\n3. Draw evidence-based conclusions\n4. Highlight areas needing more research\n\nBe objective and cite your reasoning.\n\"\"\",\n        can_ask_questions=True,  # May need clarification\n        max_questions=2,\n    ),\n    SubAgentConfig(\n        name=\"writer\",\n        description=\"Writes clear, engaging reports from research\",\n        instructions=\"\"\"You are an expert technical writer.\n\nWhen writing:\n1. Structure content logically\n2. Use clear, accessible language\n3. Include relevant examples\n4. Cite sources appropriately\n\nProduce professional-quality output.\n\"\"\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You are a research coordinator managing a team.\n\nYour team:\n- researcher: Gathers information (use async for parallel research)\n- analyst: Analyzes findings (may ask clarifying questions)\n- writer: Produces final reports\n\nWorkflow for research projects:\n1. Break the topic into research areas\n2. Assign researchers to each area (parallel, async)\n3. Monitor progress with check_task()\n4. Once research is complete, have the analyst synthesize\n5. Finally, have the writer produce the report\n\nUse async mode for research to enable parallel work.\nUse sync mode for analysis and writing for immediate results.\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # Single comprehensive request\n    result = await agent.run(\n        \"\"\"Create a comprehensive report on \"The Future of AI in Healthcare\"\n\n        Research these aspects:\n        1. Current AI applications in healthcare\n        2. Emerging technologies and trends\n        3. Challenges and ethical considerations\n\n        Then analyze the findings and write a professional report.\"\"\",\n        deps=deps,\n    )\n\n    print(\"=\" * 60)\n    print(\"FINAL REPORT\")\n    print(\"=\" * 60)\n    print(result.output)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/research-team/#workflow-breakdown","title":"Workflow Breakdown","text":""},{"location":"examples/research-team/#phase-1-parallel-research","title":"Phase 1: Parallel Research","text":"<p>The coordinator starts multiple research tasks:</p> Python<pre><code># Coordinator's actions:\ntask(description=\"Research current AI applications in healthcare\",\n     subagent_type=\"researcher\", mode=\"async\")\n# Returns: task_id_1\n\ntask(description=\"Research emerging AI healthcare technologies\",\n     subagent_type=\"researcher\", mode=\"async\")\n# Returns: task_id_2\n\ntask(description=\"Research AI healthcare challenges and ethics\",\n     subagent_type=\"researcher\", mode=\"async\")\n# Returns: task_id_3\n</code></pre>"},{"location":"examples/research-team/#phase-2-monitor-progress","title":"Phase 2: Monitor Progress","text":"<p>The coordinator checks on research:</p> Python<pre><code># Check each task\ncheck_task(task_id=task_id_1)\ncheck_task(task_id=task_id_2)\ncheck_task(task_id=task_id_3)\n</code></pre>"},{"location":"examples/research-team/#phase-3-analysis","title":"Phase 3: Analysis","text":"<p>Once research is complete, analyze findings:</p> Python<pre><code># Sync mode for immediate analysis\ntask(description=\"Analyze these research findings: [findings]\",\n     subagent_type=\"analyst\", mode=\"sync\")\n</code></pre>"},{"location":"examples/research-team/#phase-4-report-writing","title":"Phase 4: Report Writing","text":"<p>Finally, produce the report:</p> Python<pre><code># Sync mode for final output\ntask(description=\"Write a report based on this analysis: [analysis]\",\n     subagent_type=\"writer\", mode=\"sync\")\n</code></pre>"},{"location":"examples/research-team/#handling-analyst-questions","title":"Handling Analyst Questions","text":"<p>If the analyst needs clarification:</p> Python<pre><code># Analyst asks: \"Should I focus more on technical or business aspects?\"\n# Coordinator answers:\nanswer_subagent(task_id=analysis_task_id,\n                answer=\"Focus on both equally, but emphasize practical applications\")\n</code></pre>"},{"location":"examples/research-team/#extended-example-iterative-refinement","title":"Extended Example: Iterative Refinement","text":"Python<pre><code>agent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You coordinate research with iterative refinement.\n\nProcess:\n1. Initial research (parallel, async)\n2. Analysis of findings\n3. Identify gaps\n4. Additional targeted research if needed\n5. Final analysis and report\n\nIterate until the research is comprehensive.\n\"\"\",\n)\n\n# Conversation with iterative refinement\nresult1 = await agent.run(\n    \"Research AI in healthcare. Start with broad research.\",\n    deps=deps,\n)\n\nresult2 = await agent.run(\n    \"What gaps exist in the research? Conduct follow-up if needed.\",\n    deps=deps,\n    message_history=result1.all_messages(),\n)\n\nresult3 = await agent.run(\n    \"Produce the final report.\",\n    deps=deps,\n    message_history=result2.all_messages(),\n)\n</code></pre>"},{"location":"examples/research-team/#best-practices","title":"Best Practices","text":""},{"location":"examples/research-team/#1-use-async-for-independent-research","title":"1. Use Async for Independent Research","text":"Python<pre><code># Parallel research saves time\ntask(description=\"Research topic A\", mode=\"async\")\ntask(description=\"Research topic B\", mode=\"async\")\ntask(description=\"Research topic C\", mode=\"async\")\n# Check all later\n</code></pre>"},{"location":"examples/research-team/#2-use-sync-for-sequential-steps","title":"2. Use Sync for Sequential Steps","text":"Python<pre><code># Analysis needs all research first\nresearch_complete = all(check_task(t) == \"completed\" for t in task_ids)\nif research_complete:\n    task(description=\"Analyze findings\", mode=\"sync\")\n</code></pre>"},{"location":"examples/research-team/#3-clear-handoffs","title":"3. Clear Handoffs","text":"<p>Ensure each agent has what it needs:</p> Python<pre><code># Bad: Vague handoff\ntask(description=\"Analyze the stuff\", ...)\n\n# Good: Clear handoff\ntask(description=\"\"\"Analyze these findings:\n1. Current applications: [details]\n2. Emerging tech: [details]\n3. Challenges: [details]\n\nFocus on identifying trends and gaps.\"\"\", ...)\n</code></pre>"},{"location":"examples/research-team/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Advanced Features - Deep dive into features</li> </ul>"},{"location":"examples/sync-async/","title":"Sync vs Async Execution","text":"<p>This example demonstrates the difference between sync and async execution modes.</p>"},{"location":"examples/sync-async/#sync-mode-example","title":"Sync Mode Example","text":"<p>Sync mode blocks until the subagent completes:</p> Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"calculator\",\n        description=\"Performs calculations\",\n        instructions=\"You perform mathematical calculations accurately.\",\n        preferred_mode=\"sync\",  # Hint: this is a quick task\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You can delegate calculations to the calculator subagent.\nUse mode=\"sync\" for quick calculations where you need the result immediately.\n\"\"\",\n)\n\n\nasync def main():\n    result = await agent.run(\n        \"Calculate the factorial of 10\",\n        deps=Deps(),\n    )\n    print(result.output)\n    # The agent delegated with mode=\"sync\"\n    # It waited for the result before responding\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/sync-async/#async-mode-example","title":"Async Mode Example","text":"<p>Async mode runs in the background:</p> Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Performs thorough research\",\n        instructions=\"You research topics comprehensively.\",\n        preferred_mode=\"async\",  # Hint: this takes time\n        typical_complexity=\"complex\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You can delegate research to the researcher subagent.\n\nFor long research tasks:\n1. Use mode=\"async\" to start the task\n2. You'll get a task_id back\n3. Continue with other work if needed\n4. Use check_task(task_id) to get results\n\"\"\",\n)\n\n\nasync def main():\n    # First interaction: Start the research\n    result1 = await agent.run(\n        \"Start researching the history of Python. Use async mode.\",\n        deps=Deps(),\n    )\n    print(\"First response:\", result1.output)\n    # Output: \"I've started the research task. Task ID: abc123\"\n\n    # Second interaction: Check results\n    result2 = await agent.run(\n        \"Check the status of the research task\",\n        deps=Deps(),\n        message_history=result1.all_messages(),\n    )\n    print(\"Second response:\", result2.output)\n    # Output: \"The research is complete. Here are the findings...\"\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/sync-async/#parallel-tasks-example","title":"Parallel Tasks Example","text":"<p>Run multiple async tasks simultaneously:</p> Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(subagents={} if max_depth &lt;= 0 else self.subagents.copy())\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"researcher\",\n        description=\"Researches any topic\",\n        instructions=\"You research topics thoroughly.\",\n    ),\n]\n\ntoolset = create_subagent_toolset(subagents=subagents)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"\"\"You can delegate research tasks.\n\nFor multiple independent research topics:\n1. Start each as an async task\n2. Collect all task IDs\n3. Check each task for results\n4. Combine findings\n\"\"\",\n)\n\n\nasync def main():\n    deps = Deps()\n\n    # Start parallel research\n    result1 = await agent.run(\n        \"\"\"Research these three topics in parallel:\n        1. Python async/await\n        2. Python generators\n        3. Python context managers\n\n        Start each as an async task, then check results.\"\"\",\n        deps=deps,\n    )\n\n    print(result1.output)\n    # The agent started 3 async tasks, then checked each for results\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/sync-async/#auto-mode-example","title":"Auto Mode Example","text":"<p>Let the system decide:</p> Python<pre><code>subagents = [\n    SubAgentConfig(\n        name=\"worker\",\n        description=\"General purpose worker\",\n        instructions=\"You complete various tasks.\",\n        # No preferred_mode - will use auto\n    ),\n]\n\n# In the agent's prompt:\nsystem_prompt = \"\"\"You can delegate tasks to the worker subagent.\n\nUse mode=\"auto\" and the system will decide:\n- Simple tasks \u2192 sync (immediate result)\n- Complex tasks \u2192 async (background)\n\"\"\"\n</code></pre>"},{"location":"examples/sync-async/#choosing-the-right-mode","title":"Choosing the Right Mode","text":"Scenario Mode Why Quick calculation <code>sync</code> Need result immediately Simple transformation <code>sync</code> Fast to complete Deep research <code>async</code> Takes time Multiple tasks <code>async</code> Run in parallel Interactive refinement <code>sync</code> Need back-and-forth Unknown complexity <code>auto</code> Let system decide"},{"location":"examples/sync-async/#next-steps","title":"Next Steps","text":"<ul> <li>Giving Subagents Tools - Provide capabilities</li> <li>Questions - Parent-child communication</li> </ul>"},{"location":"examples/toolsets/","title":"Giving Subagents Tools","text":"<p>This example shows how to provide tools to your subagents.</p>"},{"location":"examples/toolsets/#using-toolsets_factory","title":"Using toolsets_factory","text":"<p>The <code>toolsets_factory</code> creates tools for each subagent:</p> Python<pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\nfrom pydantic_ai import Agent\nfrom subagents_pydantic_ai import create_subagent_toolset, SubAgentConfig\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n    workspace: str = \"/tmp/workspace\"\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n            workspace=self.workspace,\n        )\n\n\n# Custom toolset for file operations\ndef create_file_tools():\n    \"\"\"Create simple file operation tools.\"\"\"\n    from pydantic_ai.toolsets import FunctionToolset\n\n    toolset = FunctionToolset()\n\n    @toolset.tool\n    async def read_file(path: str) -&gt; str:\n        \"\"\"Read a file's contents.\"\"\"\n        with open(path) as f:\n            return f.read()\n\n    @toolset.tool\n    async def write_file(path: str, content: str) -&gt; str:\n        \"\"\"Write content to a file.\"\"\"\n        with open(path, \"w\") as f:\n            f.write(content)\n        return f\"Wrote {len(content)} characters to {path}\"\n\n    return toolset\n\n\ndef my_toolsets_factory(deps: Deps) -&gt; list:\n    \"\"\"Create toolsets for subagents.\"\"\"\n    return [create_file_tools()]\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"coder\",\n        description=\"Writes and manages code files\",\n        instructions=\"\"\"You write Python code.\n\nYou have access to file operations:\n- read_file(path): Read a file\n- write_file(path, content): Write to a file\n\nWrite clean, well-documented code.\n\"\"\",\n    ),\n]\n\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    toolsets_factory=my_toolsets_factory,\n)\n\nagent = Agent(\n    \"openai:gpt-4o\",\n    deps_type=Deps,\n    toolsets=[toolset],\n    system_prompt=\"You can delegate coding tasks to the coder subagent.\",\n)\n\n\nasync def main():\n    result = await agent.run(\n        \"Create a Python script that prints 'Hello World' and save it to /tmp/hello.py\",\n        deps=Deps(),\n    )\n    print(result.output)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/toolsets/#per-subagent-toolsets","title":"Per-Subagent Toolsets","text":"<p>Give different tools to different subagents:</p> Python<pre><code>def selective_toolsets_factory(deps: Deps) -&gt; list:\n    \"\"\"Create toolsets based on the subagent context.\"\"\"\n    # You could check deps or other context to customize\n    return [create_file_tools()]\n\n\n# Or specify toolsets directly in the config\nsubagents = [\n    SubAgentConfig(\n        name=\"reader\",\n        description=\"Reads and analyzes files\",\n        instructions=\"You read files and analyze their contents.\",\n        toolsets=[create_read_only_tools()],  # Only read access\n    ),\n    SubAgentConfig(\n        name=\"writer\",\n        description=\"Writes files\",\n        instructions=\"You write files.\",\n        toolsets=[create_file_tools()],  # Full access\n    ),\n]\n</code></pre>"},{"location":"examples/toolsets/#using-pydantic-ai-backend","title":"Using pydantic-ai-backend","text":"<p>For comprehensive file operations, use pydantic-ai-backend:</p> Python<pre><code>from pydantic_ai_backends import create_console_toolset, StateBackend\n\n\n@dataclass\nclass Deps:\n    subagents: dict[str, Any] = field(default_factory=dict)\n    backend: StateBackend = field(default_factory=StateBackend)\n\n    def clone_for_subagent(self, max_depth: int = 0) -&gt; \"Deps\":\n        return Deps(\n            subagents={} if max_depth &lt;= 0 else self.subagents.copy(),\n            backend=self.backend,  # Share the backend\n        )\n\n\ndef backend_toolsets_factory(deps: Deps) -&gt; list:\n    \"\"\"Create console toolset from backend.\"\"\"\n    return [create_console_toolset(deps.backend)]\n\n\nsubagents = [\n    SubAgentConfig(\n        name=\"coder\",\n        description=\"Writes code with full filesystem access\",\n        instructions=\"\"\"You have access to filesystem operations:\n- ls(path): List directory contents\n- read_file(path): Read a file\n- write_file(path, content): Write to a file\n- edit_file(path, old, new): Edit a file\n- glob(pattern): Find files matching pattern\n- grep(pattern, path): Search file contents\n\"\"\",\n    ),\n]\n\ntoolset = create_subagent_toolset(\n    subagents=subagents,\n    toolsets_factory=backend_toolsets_factory,\n)\n</code></pre>"},{"location":"examples/toolsets/#built-in-tools","title":"Built-in Tools","text":"<p>Use Pydantic AI's built-in tools:</p> Python<pre><code>from pydantic_ai.builtin_tools import WebSearchTool\n\nsubagents = [\n    SubAgentConfig(\n        name=\"web-researcher\",\n        description=\"Researches using web search\",\n        instructions=\"You research topics using web search.\",\n        agent_kwargs={\n            \"builtin_tools\": [WebSearchTool()],\n        },\n    ),\n]\n</code></pre>"},{"location":"examples/toolsets/#combining-multiple-toolsets","title":"Combining Multiple Toolsets","text":"Python<pre><code>def comprehensive_toolsets_factory(deps: Deps) -&gt; list:\n    \"\"\"Create multiple toolsets for subagents.\"\"\"\n    return [\n        create_console_toolset(deps.backend),  # File operations\n        create_todo_toolset(),  # Task tracking\n        create_search_toolset(),  # Search capabilities\n    ]\n</code></pre>"},{"location":"examples/toolsets/#best-practices","title":"Best Practices","text":""},{"location":"examples/toolsets/#1-principle-of-least-privilege","title":"1. Principle of Least Privilege","text":"<p>Only give subagents the tools they need:</p> Python<pre><code># Good: Specific tools for specific tasks\nSubAgentConfig(\n    name=\"reader\",\n    instructions=\"You read and analyze files.\",\n    toolsets=[create_read_only_tools()],  # No write access\n)\n\n# Avoid: Giving everything to everyone\nSubAgentConfig(\n    name=\"helper\",\n    toolsets=[all_tools],  # Too permissive\n)\n</code></pre>"},{"location":"examples/toolsets/#2-document-available-tools","title":"2. Document Available Tools","text":"<p>Include tool documentation in instructions:</p> Python<pre><code>SubAgentConfig(\n    name=\"coder\",\n    instructions=\"\"\"You write Python code.\n\nAvailable tools:\n- read_file(path): Read file contents\n- write_file(path, content): Write to file\n- execute(command): Run shell command\n\nAlways read existing files before modifying them.\n\"\"\",\n)\n</code></pre>"},{"location":"examples/toolsets/#3-handle-tool-errors","title":"3. Handle Tool Errors","text":"<p>Guide subagents on error handling:</p> Python<pre><code>instructions=\"\"\"\nIf a tool call fails:\n1. Check if the path/parameters are correct\n2. Try an alternative approach\n3. Report the error clearly if unresolvable\n\"\"\"\n</code></pre>"},{"location":"examples/toolsets/#next-steps","title":"Next Steps","text":"<ul> <li>Questions - Parent-child communication</li> <li>Nesting - Subagents with their own subagents</li> </ul>"}]}